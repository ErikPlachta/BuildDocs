/**
 * @access private
 * @file DocsToUi\index.ts
 * @summary Converting JSON data generated by BuildDocs module into markdown and/or HTML.
 * @namespace {build-docs.DocsToUi}
 * @module DocsToUi
 * @memberof namespace:build-docs
 * @requires module:BuildHtml
 * @fires module:BuildHtml
 * @changelog 0.0.1 | 2023-07-13 | Erik Plachta | docs: Initial version released as basic concept.
 * @changelog 0.0.2 | 2023-07-14 | Erik Plachta | docs: Built out more complete data extraction
 * @changelog 0.0.3 | 2023-07-15 | Erik Plachta | docs: Finalized data extraction for building HTML. Add files,
 * @changelog 0.0.4 | 2023-07-21 | Erik Plachta | docs: Finalized concept for ElementsProcessed.
 * @changelog 0.0.5 | 2023-07-22 | Erik Plachta | docs: Created module BuildHtml and verified finalized concept html generation.
 * @changelog 0.0.6 | 2023-07-23 | Erik Plachta | docs: Cleanup. Organizing, documenting, adding TODOs, verified integrity.
 * @changelog 0.0.61| 2023-07-23 | Erik Plachta | docs: Simplified how content is being rendered. Created helper functions. Add more complete class properties.
 *
 * @todo 2023-07-15 | Erik Plachta | Add more complete config options
 * @todo 2023-07-15 | Erik Plachta | Add markdown generation
 */

import { randomUUID } from 'crypto' // Generate unique IDs for elements.

import {
  Comments, //-- Comments built by DocsToJson, ready to be processed.
  CommentsProcessed,
  Namespace,
  Module,
  File,
  DocsToUiConfig,
  Element,
  Elements,
  ElementsProcessed,
  htmlConfig,
  Config,
  Logging_config,
  ErrorRecord,
} from '../types'

import BuildHtml from './utils/BuildHtml'
import ManageHtmlContent from './utils/ManageHtmlContent'

/**
 * Converting JSON data generated by BuildDocs module into markdown and/or HTML.
 *
 * @access private
 * @class
 * @memberof module:DocsToUi
 * @summary Converting JSON data generated by BuildDocs module into markdown and/or HTML.
 * @param {DataItem[]} data - The JSON data to convert
 * @param {Config} config - The configuration for the conversion
 * @requires module:BuildHtml
 * @fires module:BuildHtml
 */
class DocsToUi {
  public config: DocsToUiConfig
  public comments: Comments[]
  private LogLevel: Logging_config['level']['value']
  public files: File[]
  public namespaces: Namespace[]
  public modules: Module[]
  public processedData: CommentsProcessed[] | []
  public contentGroups: CommentsProcessed[] | []
  public contentGroupIdentifier: string | 'namespaces' | 'modules' | 'files' | 'types' | 'access' | 'author' | 'version'
  public elements: ElementsProcessed

  public title: string
  public htmlConfig: htmlConfig

  public errors: ErrorRecord[] = []

  //-----------

  /**
   * @constructor
   * @access public
   * @memberof module:DocsToUi
   * @param {Logging['option']['level']['value']} LogLevel - The log level to use.
   * @param {Comments[]} comments - The JSON data object containing all comment info to converted.
   * @param {Config} config - The configuration for the conversion.
   * @todo 2023-07-23 | Erik Plachta | Cleanup properties. Move things into config, organize as needed, verify integrity.
   */
  constructor(
    LogLevel: Logging_config['level']['value'],
    comments: Comments[],
    config: {
      outputFormat: {
        markdown: boolean
        html: boolean
      }
    },
  ) {
    //---------------------------------
    //-- Class properties

    //TODO: Get this from config and create way to define it.

    this.contentGroupIdentifier = 'namespaces' //TODO: Get this from config.

    this.comments = comments
    this.config = config
    this.LogLevel = LogLevel
    this.files = []
    this.namespaces = []
    this.modules = []
    this.processedData = this.processComments(comments)
    this.contentGroups = this.getContentGroups()

    //-- Evaluate `this.processedData` and `this.contentGroups`, assign `ContentToRender` values.
    this.elements = this.buildElements()

    this.title = 'DocsToUi'
    this.htmlConfig = {
      html: {
        lang: 'en',
        classList: ['h-[100vh]'],
      },
      head: {
        meta: [
          {
            type: 'viewport',
            value: 'width=device-width, initial-scale=1.0',
          },
          {
            type: 'charset',
            value: 'utf-8',
          },
        ],
        scripts: [
          {
            src: 'https://cdn.tailwindcss.com',
          },
          {
            defer: true,
            value: `${ManageHtmlContent.toString()}\nManageHtmlContent()`,
          },
        ],
        styles: [],
      },

      body: {
        classList: ['bg-gray-100', 'flex', 'flex-col', 'gap-8', 'h-[100vh]'],
        styles: [],
      },
    }

    //---------------------------------
    //-- Class Integrity / Info Properties
    this.errors = []

    //---------------------------------
    this.__init__(LogLevel, comments, config)
  }
  //----------------------------------------------------------------------------
  /**
   * Take params
   */
  __init__(LogLevel: Logging_config['level']['value'], comments: Comments[], config: DocsToUiConfig) {
    if (LogLevel > 4) console.log('DocsToUi.__init__')

    console.log('TODO: Onboard DocsToUi.__init__ function.')
  }

  //----------------------------------------------------------------------------
  /**
   * Process data for easier use
   * @param {Comments[]} comments - The data to process
   * @return {CommentsProcessed[]} The processed data
   * @todo 2013-07-18 | Erik Plachta | Move into DocsToJson module from here.
   */
  processComments(comments: Comments[]): CommentsProcessed[] {
    const processedData: CommentsProcessed[] = []

    //-----------------------------
    // 1. First pass through all items to extract individual doc info.
    comments &&
      comments.map((item: Comments) => {
        processedData.push({
          id: item.id,

          //-- if it's got a namespace it's a root item.
          isRootItem: item.comments?.namespace?.[0]?.description ? true : false,

          fileDetails: {
            //-- All return this even if it's not a file because it's relational reference.
            fileName: item.fileName,
            filePath: item.filePath,
            createdDate: item.createdDate,
            modifiedDate: item.modifiedDate,
          },

          type: item.comments?.type?.[0]?.description
            ? {
                type: item.comments?.type?.[0]?.description.split('}')[0].replace('{', ''),
                description: item.comments?.type?.[0]?.description.split('}')[1].trim(),
              }
            : item.comments?.file?.[0]?.description
            ? {
                type: 'file',
                description: item.comments?.file?.[0]?.description,
              }
            : null,

          version: item.comments?.version?.[0]?.description ? item.comments?.version?.[0]?.description : null,

          author: item.comments?.author?.[0]?.description ? item.comments?.author?.[0]?.description : null,

          access: item.comments?.access?.[0]?.description ? item.comments?.access?.[0]?.description : null,

          description: item.comments?.description?.[0]?.description
            ? item.comments?.description?.[0]?.description
            : null,

          summary: item.comments?.summary?.[0]?.description ? item.comments?.summary?.[0]?.description : null,

          props:
            item.comments?.param?.length > 0
              ? item.comments.param.map(param => {
                  const args = param.description.match(/(\{[^}]*\}|\[[^\]]*\]|`[^`]*`|[^ ]+)/g)
                  const [type, name, ...description] = args || []

                  return {
                    id: item.id,
                    type: type?.replace('{', '').replace('}', '') || null,
                    name: name?.replace('[', '').replace(']', '') || null,
                    description: description?.join(' ').replace('-', '') || null,
                  }
                })
              : [],

          arguments:
            item.comments?.argument?.length > 0
              ? item.comments?.argument.map(argument => {
                  const args = argument.description.match(/(\{[^}]*\}|\[[^\]]*\]|`[^`]*`|[^ ]+)/g)
                  const [type, name, ...description] = args || []

                  return {
                    id: item.id,
                    type: type?.replace('{', '').replace('}', '') || '',
                    name: name?.replace('[', '').replace(']', '') || '',
                    description: description?.join(' ').replace('-', '') || '',
                  }
                })
              : [],

          changelog:
            item.comments?.changelog?.length > 0
              ? item.comments?.changelog.map(changelog => {
                  return changelog?.description
                })
              : [],

          todo:
            item.comments?.todo?.length > 0
              ? item.comments?.todo.map(todo => {
                  return todo?.description
                })
              : [],

          bug:
            item.comments?.bug?.length > 0
              ? item.comments?.bug.map(bug => {
                  return bug?.description
                })
              : [],

          example:
            item.comments?.example?.length > 0
              ? item.comments?.example.map(example => {
                  return example?.description
                })
              : [],

          //-----------------------------
          //-- Creating empty values for the below, which will be populated on next pass.
          parent: [],
          children: [],
          related: [],

          //-----------------------------
          //-- Extract description from comment for namespace(s)
          namespaces:
            item.comments?.namespace?.length > 0
              ? item.comments?.namespace.map(namespace => {
                  //-- Cleanup description to prepare to record
                  const description = namespace?.description.replace('{', '').replace('}', '')

                  //-- Record namespace if isn't already defined in global state.
                  // ( Should never create duplicates either way, but just in case. )
                  if (this.namespaces.filter(item => description !== item.description)) {
                    this.namespaces.push({
                      id: item.id,
                      description: description,
                    })
                  }

                  //-- return object for the item itself as a value for the `namespaces` property.
                  return description
                })
              : [],

          //-----------------------------
          //-- Extract description from comment for module(s)
          modules:
            item.comments?.module?.length > 0
              ? item.comments?.module.map(thisModule => {
                  const value = thisModule.description
                  this.modules.push({
                    id: item.id,
                    description: value,
                  })
                  return value
                })
              : [],

          //-----------------------------
          memberOf:
            item.comments?.memberof?.length > 0
              ? item.comments?.memberof.map(memberof => {
                  const value = memberof?.description.split(':')
                  return {
                    type: value[0],
                    description: value[1],
                  }
                })
              : [],

          requires:
            item.comments?.requires?.length > 0
              ? item.comments?.requires.map(require => {
                  const rootDesc = require.description
                  const { type, name, description } = rootDesc.includes('https://nodejs.org/api')
                    ? //-- Node Module
                      {
                        type: 'node-module',
                        name: rootDesc.split(' | ')[1]?.replace('}', ''),
                        description: rootDesc.split('{@link ')[1]?.split(' | ')[0],
                      }
                    : rootDesc.split(':')[0].includes('module')
                    ? //-- Custom Module
                      {
                        // id: item?.id || null,
                        type: rootDesc.split(':')[0],
                        name: rootDesc.split(':')[1],
                        description: rootDesc.split(':')[1],
                      }
                    : //-- Everything else that isn't programmed in yet.
                      {
                        // id: item?.id || null,
                        type: 'unknown', //TODO: update this
                        name: null,
                        description: rootDesc,
                      }
                  return {
                    id: item.id,
                    type: type || null,
                    name: name || null,
                    description: description || null,
                  }
                })
              : [],
        })
      })

    // 2. Second  pass to add associations between items, recording files, etc
    processedData.map((item: CommentsProcessed) => {
      // 2.1. if has an @memberof tagging.
      if (item?.memberOf && item?.memberOf?.length > 0) {
        item.memberOf.map(memberOf => {
          //-----------------
          // 1.1 Assign relationships for namespaces
          if (memberOf.type === 'namespace') {
            this.namespaces.map(thisNamespace => {
              if (thisNamespace.description === memberOf.description) {
                //-- Add the parent id as the parent to the children
                item.parent.push({
                  id: thisNamespace.id,
                  type: item?.type?.type || null,
                  association: 'namespace',
                  description: thisNamespace.description,
                })
              } else {
                //TODO: onboard or remove this logic.
                // console.log('thisNamespace.value, memberOf.value', thisNamespace.value, memberOf.value)
                const allMemberValues = memberOf?.description.split(' | ') || []
                // const match = allMemberValues.filter((value) => { value === thisNamespace.value })
                const allNamespaceValues = thisNamespace.description.split(' | ') || []
                // const match = allNamespaceValues.filter((value) => { value === memberOf.value })
              }
            })
          }

          //-----------------
          // 1.2. Assign relationships for modules
          if (memberOf.type === 'module') {
            //-- Loop through all modules, check to see if the item is a member of the module.
            this.modules.map(thisModule => {
              if (thisModule.description === memberOf.description) {
                //-- Add the parent id as the parent to the children
                item.parent.push({
                  id: thisModule.id,
                  type: item?.type?.type || null,
                  association: 'module',
                  description: thisModule.description,
                })

                //-- Find the parent and assign the child id to it
                processedData.map((parentItem: CommentsProcessed) => {
                  if (parentItem.id === thisModule.id) {
                    parentItem.children.push({
                      id: item.id,
                      type: item.type?.type || null,
                      association: 'module',
                      description: thisModule.description,
                    })
                  }
                }) // end of adding children associations for parent members of modules
              } // end of module names match
            }) // end of checking match for module names
          } //-- end of checking if memberOf.type === 'module'
        }) //-- end of looping through all memberOf
      } //-- end of checking if item.memberOf.length > 0

      //------------------------------------------------------------------
      // 2.2 If item is a file append this.files array. (children added after this loop)
      if (
        item.type?.type &&
        item.type.type == 'file' &&
        item.type?.description &&
        item.type?.description != (undefined || null)
      ) {
        this.files.push({
          id: item.id,
          description: item.type.description,
          filePath: item.fileDetails.filePath,
        })
      }
    }) //-- end of looping through all processedData

    // 3. If item is NOT a Root Item, add it's parent file to the files parent array.
    processedData.map((item: CommentsProcessed) => {
      if (item?.isRootItem != true) {
        // 3.1 If item is NOT a Root Item, add it's parent file to the files parent array.
        this.files.map(file => {
          if (file.filePath === item.fileDetails.filePath) {
            item.parent.push({
              id: file.id,
              type: item?.type?.type || null,
              association: 'file',
              description: file.description,
            })
          }
          // 3.2 Make sure proper parent association
          else {
            let fileToUpdate: any = processedData.filter(CommentsProcessed => {
              CommentsProcessed.id === file.id
            })
            //-- If there is a file, and there is not already an entry for it, add it.
            if (fileToUpdate.children && fileToUpdate.children.filter((child: any) => child.id !== item.id)) {
              fileToUpdate.children.push({
                id: item.id,
                type: 'file',
                description: file.description,
              })
            }
          }
        })
      }
    }) //-- end of looping through all processedData

    return processedData
  }

  //----------------------------------------------------------------------------
  //----------------------------------------------------------------------------
  //-- Building actual objects based on what UI content needs.

  /**
   * This function is the main function that generates the `this.elements` object.
   *
   * 1. Create an array to hold the Element and all related info to be generated.
   * 2. Executes this.buildHeader() to get Elements Processed for the Main Nav component.
   * 3. Executes this.buildGroupContentWrapper() to get Elements Processed for the Content Wrapper component.
   *
   * @access private
   * @type {function} buildElements
   * @function buildElements
   * @memberof module:DocsToUi
   * @summary Manages parsing Processed Data and builds `this.elements`.
   * @description This function is the main function that generates the `this.elements` object.
   * @returns {boolean} True if successful, false if not.
   * @fires buildHeader
   * @fires buildGroupContentWrapper
   * @return {array[object]} - An array of objects, each containing the id of the element, the id of the processed item it relates to, and the data to render.
   *
   * @todo  2023-07-20 | Erik Plachta | Onboard helper functions
   */
  buildElements(): ElementsProcessed {
    //-- Define IDs for the top-level elements.
    const parentIds = {
      body: randomUUID(),
      header: randomUUID(),
      navHeader: randomUUID(),
      navHeaderList: randomUUID(),
      main: randomUUID(),
      contentWrapper: randomUUID(),
      footer: randomUUID(),
    }

    // 1. Create an array to hold the Element and all related info to be generated.
    let ElementsProcessed: ElementsProcessed = {
      id: randomUUID(),
      createdDate: new Date(),

      description:
        'Top-level wrapper around all elements. Root consists of Body, Header, Main, Footer, and all children are rendered within.',
      parents: { ...parentIds },
      HtmlElements: [
        {
          id: parentIds.body,
          createdDate: new Date(),
          title: 'body',
          description: 'The body wrapping all content.',
          parents: { ...parentIds },
          Elements: [],
        },
      ],
      //TODO: 2023-07-20 | Erik Plachta | Onboard these helper functions once finalized.
      // helpers: {
      // getElements: () => [],
      // getElementById: (id: string) => [],
      // getElementsById: (id: string) => [],
      // getElementsByParentId: (parent: string) => [],
      // getElementsByRole: (role: string) => [],
      // getElementsByGroup: (group: string) => [],
      // getElementsBySubGroup: (subGroup: string) => [],
      // getElementsByType: (type: string) => [],
      // },
    } // end of base declaration.

    // 3. Build the Main navigation, one link for each namespace.
    ElementsProcessed = this.buildHeader(ElementsProcessed)

    // 4. Build Content Wrapper, Tab-Strip-Nav, and Content for each namespace.
    ElementsProcessed = this.buildGroupContentWrapper(ElementsProcessed)

    // 5. Build the Footer at bottom of dom.
    ElementsProcessed.HtmlElements[ElementsProcessed.HtmlElements.length - 1].Elements.push({
      id: parentIds.footer,
      parent: null,
      //TODO: Add footer content
      description: 'Footer within the rendered content.',
      elementType: 'footer',
      classList: [
        'w-full text-sm bottom-0 p-0 m-0 p-2 border-solid border-2 bg-white flex flex-col gap-4 text-center mx-auto max-w-4xl',
      ],
      dataAttributes: {
        value: `BuildDocs | Â© ${new Date().getFullYear()} - Erik Plachta`,
        type: null,
        path: null,
        role: 'footer',
        group: null,
        subGroup: null,
        id: null,
      },
      children: [],
      helpers: {},
    })

    // console.log('ElementsProcessed: ', ElementsProcessed)

    // 5. Returns finalized ElementsProcessed object.
    return ElementsProcessed
  }

  //-------------------------------
  //-- Utilities used by buildElements

  /**
   * Generate Header, Nav, and Nav-Links for each Content-Group (namespace).
   *
   * @function buildHeader
   * @access private
   * @memberof module:DocsToUi
   * @summary Generate Header, Nav, and Nav-Links for each Content-Group (namespace).
   * @description Builds the header and nav elements. The builds a link within nav based on each Content-Group (namespace).
   * @type {function} buildHeader
   * @param {object} ElementsProcessed - The object containing all elements to be rendered.
   * @return {object} ElementsProcessed - The object containing all elements to be rendered.
   */
  buildHeader(ElementsProcessed: ElementsProcessed): ElementsProcessed {
    // 1. Build the Header element.
    const Header: Elements = {
      id: ElementsProcessed.parents.header, //-- The ID of the raw json data all content is being rendered from.
      title: 'header',
      description: 'Header element for the page. Contains the main navigation.',
      createdDate: new Date(),
      parents: { ...ElementsProcessed.parents },
      Elements: [
        {
          id: ElementsProcessed.parents.header,
          orderId: 2,
          parent: null,
          description: 'Header element for the page. Contains the main navigation.',
          elementType: 'header',
          classList: [
            'w-full p-0 m-0 px-4 border-solid border-2 bg-white flex flex-col gap-4 max-w-8xl mx-auto',
            'overflow-scroll min-h-[fit-content] h-[fit-content] flex-grow-0 flex-shrink-0 flex-basis-auto p-b-4',
          ],
          dataAttributes: {
            value: null,
            type: null,
            path: null,
            role: 'header',
            group: null,
            subGroup: null,
            id: null,
          },
          children: [],
        },
      ],
    } // end of base UL to hold LIs.

    // 2. Build the Navigation (`nav`).
    const NavHeader: Element = {
      id: ElementsProcessed.parents.header,
      parent: ElementsProcessed.parents.navHeader,
      description: "Nav container holding the nav element and it's children within content-wrapper for group.",
      elementType: 'nav',
      classList: ['max-w-4xl mx-auto w-full px-4 pt-2 text-md'],
      dataAttributes: {
        value: null,
        type: null,
        path: null,
        role: 'nav-header',
        group: ElementsProcessed.parents.navHeader,
        subGroup: null,
        id: 'nav-header',
        active: false,
      },
      children: [],
    }

    // 3. Build the wrapper (`ul`) for main nav links (`li`). Add to Nav element.
    const NavHeaderList: Element = {
      id: ElementsProcessed.parents.navHeaderList,
      parent: ElementsProcessed.parents.navHeader,
      description: `Main navigation list, holding a link for each namespace.`,
      elementType: 'ul',
      classList: ['flex flex-row gap-6 mt-auto h-full'],
      dataAttributes: {
        value: null,
        type: null,
        path: null,
        role: 'nav-header-list', //-- Role of content when rendered to the UI.
        group: null,
        subGroup: null,
        id: null,
      },
      children: [],
    } // end of base UL to hold LIs.

    // 4. Get all Content-Groups (namespaces), and create link in header nav each. (Mapping through, and if match pushing to NavHeaderList children).
    let firstTab = true //-- Default active tab styling.
    this.contentGroups.map((item: CommentsProcessed) => {
      // let test = this.contentGroups.map((item: CommentsProcessed) => {
      if (item.namespaces.length > 0) {
        // 2. Create the main nav elements for each namespace.
        const NavHeaderLink: Element = {
          id: item.id,
          parent: ElementsProcessed.parents.navHeaderList,
          description:
            item.description ||
            item.summary ||
            `Link within the tab-strip-nav-list for for module '${item.modules[0]}' within namespace '${item.namespaces[0]}'.`,
          elementType: 'li',
          classList: [
            'py-2 px-4 border-solid border-b-4 hover:border-blue-500/80',
            // active tab styling
            `${firstTab === true ? 'border-blue-500' : 'border-transparent'}`,
          ],
          dataAttributes: {
            value:
              item.namespaces[0]?.toUpperCase() ||
              item.modules[0]?.toUpperCase() ||
              item.type?.description ||
              'no-value-set',
            type: item.type?.type || item.type?.description || null,
            path: item.fileDetails.filePath,
            role: 'nav-header-link', //-- Role of content when rendered to the UI.
            group: item.namespaces[0], //-- Used to target content to make visible.
            subGroup: null, //-- none at this level. // TODO: Verify this is correct.
            id: item.namespaces[0], //-- Unique ID to connect tab-strip-nav to it's related content to display. For example, `overview-summary` is the id for the overview tab and the overview content.
            active: firstTab === true ? true : false, //-- Used to determine if the content should be visible or not.
          },
          children: [],
        } // end of navHeaderList declaration.
        firstTab = false //-- Default active tab styling.

        // 3. Add the nav link to the navHeader object if it's defined.
        NavHeaderList.children.push(NavHeaderLink)
        // return NavHeaderLink
      }
    }) // -- end of making links for namespaces.

    // 4. Populate the navHeader object with the navHeaderList.
    NavHeader.children.push(NavHeaderList)

    // 5. Populate the header object with the navHeader.
    Header.Elements[0].children.push(NavHeader)

    // 6. Populated main ElementsProcessed HTML Elements with new content.
    ElementsProcessed.HtmlElements.push(Header)

    // 7. Returns updated ElementsProcessed object with Header and Nav.
    return ElementsProcessed
  }

  //-------------------------------------
  //-- Build Content Wrapper, Tab-Strip-Nav, and Content for each namespace.

  /**
   * For each namespace, creates a content wrapper, tab-strip-nav, and content.
   *
   * @access private
   * @type {function} buildGroupContentWrapper
   * @function buildGroupContentWrapper
   * @param {object} ElementsProcessed - The object containing all elements to be rendered.
   * @return {object} ElementsProcessed - The object containing all elements to be rendered.
   * @summary Evaluates namespaces and creates content to be built into main.
   * @description For each namespace, creates a content wrapper, tab-strip-nav, and content.
   * @fires buildTabStripNav
   * @fires buildContent
   *
   * @todo 2023-07-20 | Erik Plachta | Add logic to build default tab for overview
   */
  buildGroupContentWrapper(ElementsProcessed: ElementsProcessed): ElementsProcessed {
    //TODO: 2023-07-20 | Erik Plachta | Add logic to build default tab for overview, too.

    // console.log('buildGroupContentWrapper:')

    //-- Create IDs here to use in the Group-Content-Wrapper, so can pass down as parents.
    const tabStripNavId = randomUUID()
    const tabStripNavListId = randomUUID()

    let firstContentGroup = true
    // 1. Get all Namespaces and create main nav elements for them.
    this.contentGroups.map((item: CommentsProcessed) => {
      if (item.namespaces.length > 0) {
        // 2. Create the main nav elements for each namespace.
        const GroupContentWrapper: Elements = {
          id: item.id, //-- The ID of the raw json data all content is being rendered from.
          createdDate: new Date(),
          title: `group-content-wrapper-${item.namespaces[0]}`,
          description: `Holds all elements for the namespace: ${item.namespaces[0]}.`,
          parents: {
            ...ElementsProcessed.parents,
            container: item.id,
            tabStripNav: tabStripNavId,
            tabStripNavList: tabStripNavListId,
          },
          Elements: [
            {
              id: item.id,
              orderId: 3,
              parent: ElementsProcessed.parents.main,
              description: `Div within 'main' for Group (namespace) '${item.namespaces[0]}'. Holds the tab-strip-nav and all GroupContentWrapper (which holds GroupContent).`,
              elementType: 'div',
              classList: [
                'relative max-w-4xl mx-auto flex flex-col bg-white bg-opacity-60 w-full h-full',
                // 'overflow-auto'
                // Default first as active.
                `${firstContentGroup == true ? '' : 'hidden'}`,
              ],
              dataAttributes: {
                value: null,
                type: null,
                path: null,
                role: 'group-content-wrapper',
                group: item.namespaces[0],
                subGroup: null,
                id: item.namespaces[0], //-- Unique ID to connect tab-strip-nav to it's related content to display. For example, `overview-summary` is the id for the overview tab and the overview content.
                active: firstContentGroup == true ? true : false,
              },
              children: [],
            },
          ],
        } // end of this element.

        // 3. Build Group Content
        const GroupContent: Element = {
          id: randomUUID(),
          parent: item.id,
          description: `Wrapper to hold content within group-content-wrapper, for group (namespace) '${item.namespaces[0]}'.`,
          elementType: 'div',
          classList: [
            'border-solid border-2 border-t-0 rounded-b-xl h-full p-x-4 p-b-4',
            'overflow-hidden'
          ],
          dataAttributes: {
            value: null, // container, no value.
            type: null, // container, no value.
            path: null, // container, no value.
            role: 'group-content', // wrapper around all content
            group: item.namespaces[0], // namespace to show-hide based on nav link clicked.
            subGroup: null, // container, no value.
            id: null, // container, no value.
            active: false, // TODO: get this setup right.
          },
          children: [],
        }

        // 4. Build the tab strip nav for the content-group (namespace).
        GroupContent.children.push(
          // Builds overview tab first, then the rest of the tabs are members of the content-group (namespace).
          this.buildTabStripNav(item, item.namespaces[0], item.id, tabStripNavId, tabStripNavListId),
        )

        // 5. Build the Content-Group children.
        GroupContent.children.push(
          // Builds the Overview content first, then the rest of the tabs are members of the content-group (namespace).
          ...this.buildGroupContent(item, item.namespaces[0], item.id, ElementsProcessed),
        )

        // 6. Update Wrapper around content with the GroupContent.
        // The Wrapper only has one child, the GroupContent, which contains all additional content.
        GroupContentWrapper.Elements[0].children.push(GroupContent)

        // 4. Add the main nav elements to the ElementsProcessed object.
        ElementsProcessed.HtmlElements.push(GroupContentWrapper)
      } // -- end of if namespace check.

      firstContentGroup = false // no longer first, so false to hide
    }) // -- end of looping through root items.

    // 4. Return updated object with the main nav elements within.
    return ElementsProcessed
  }

  /**
   * Utility for building the tab strip nav based on the processed data.
   *
   * Get all modules within the namespace.
   *
   * 1. Build TabStripNav element, a `nav` element, which will hold the tab strip nav list.
   * 2. Execute `TabStripNav.helpers.getChildren()`, which populates all children within TabStripNav.
   * 3. Build the tab strip nav wrapper.
   * 4. Build the tab strip nav list.
   * 5. Build the tab strip nav list items.
   *
   *
   * @returns {Element} TabStripNav - The tab strip nav element.
   * @todo build this out to render content properly.
   * @todo determine if any defaults should exist.
   */
  buildTabStripNav(
    parentItem: CommentsProcessed,
    group: string,
    parentId: string,
    tabStripNavId: string,
    tabStripNavListId: string,
  ): Element {
    // 1. Build TabStripNav element, a `nav` element, which will hold the tab strip nav list.
    const TabStripNav: Element = {
      id: tabStripNavId,
      parent: parentId,
      description: "Nav container holding the nav element and it's children within content-wrapper for group.",
      elementType: 'nav',
      classList: [
        'w-full flex flex-row gap-2 bg-gray-100 sticky top-0 z-10 text-sm',
        'overflow-wrap min-h-[fit-content] h-[fit-content] flex-grow-0 flex-shrink-0 flex-basis-auto pb-0 overflow-scroll',
      ],
      dataAttributes: {
        value: null,
        type: null,
        path: null,
        role: 'tab-strip-nav',
        group: group || parentId,
        subGroup: null,
        id: null,
      },
      children: [],
    } // end of tabStripNav declaration.

    // 2. Build the tab strip nav wrapper.
    const tabStripNavList: Element = {
      id: tabStripNavListId,
      // id: tabStripNavListId,
      parent: tabStripNavId,
      description: `List holding tab-strip-nav-links for namespace with id: '${parentId}'.`,
      elementType: 'ul',
      classList: ['flex w-full flex-row w-full gap-2 w-full bg-transparent'],
      dataAttributes: {
        value: null,
        type: null,
        path: null,
        role: 'tab-strip-nav-list', //-- Role of content when rendered to the UI.
        group: group || parentId,
        subGroup: null,
        id: null,
        active: false,
      },
      children: [],
    }

    // 3. Build Container for Content-Group Tab-Strip-Links and define Overview Tab.
    const tabStripLinks: Element[] = [
      // 4. Build The overview tab definition, which is always first.
      {
        id: parentItem.id,
        parent: tabStripNavListId,
        description: `Link within the tab-strip-nav-list for for module '${parentItem.modules[0]}' within namespace '${parentItem.namespaces[0]}'.`,
        elementType: 'li',
        classList: [
          'bg-white h-full py-2 px-4 rounded-t-md border-2 border-solid border-b-blue-500 hover:bg-opacity-90 hover:border-b-blue-500/50',
        ],
        dataAttributes: {
          value: 'Overview',
          type: parentItem.type?.type || parentItem.type?.description || null,
          path: parentItem.fileDetails.filePath,
          role: 'tab-strip-nav-link', //-- Role of content when rendered to the UI.
          group:
            group ||
            parentItem.namespaces[0] ||
            parentItem.memberOf?.filter(value => value.type == 'namespace')[0]?.description ||
            parentItem.parent?.filter(value => value.type == 'namespace')[0]?.description ||
            parentItem.modules[0] ||
            parentItem.memberOf?.filter(value => value.type == 'module')[0]?.description ||
            null,
          //-- Either Module, Type Description ( like file name, function name, etc), or NULL
          subGroup: parentItem.modules[0] || parentItem.type?.description || null,
          id: parentItem.modules[0],
          active: false,
        },
        children: [],
      },
    ] //-- End of tabStripLinks array definition with overview tab.

    // 5. Define the rest of the tab-strip-nav-links for the content-group (namespace).
    //    Gets all modules within the namespace, creates a tab for them.
    this.processedData.map((item: CommentsProcessed) => {
      // 5.1 If item's parent is the namespace, build it.
      if (item.parent.filter(itemParent => itemParent.id === parentId).length > 0) {
        // 5.2 Build any additional tab-strip-nav-links for the content-group (namespace).
        const tabStripLink: Element = {
          id: item.id,
          parent: tabStripNavListId,
          description: `Link within the tab-strip-nav-list for for module '${item.modules[0]}' within namespace '${item.namespaces[0]}'.`,
          elementType: 'li',
          classList: [
            'bg-white h-full py-2 px-4 rounded-t-md border-2 border-solid border-b-transparent-500 hover:bg-opacity-90 hover:border-b-blue-500/50',
          ],
          content: [item.modules[0]?.toUpperCase() || 'INVALID_ITEM_TITLE'], //TODO: verify this is correct.
          dataAttributes: {
            value: null,
            type: item.type?.type || item.type?.description || 'INVALID_ITEM_TYPE', //TODO: verify this is correct.
            path: item.fileDetails.filePath,
            role: 'tab-strip-nav-link',
            group: group || 'INVALID_ITEM_GROUP', //TODO: verify this is correct.
            // item.namespaces[0] ||
            // item.memberOf?.filter(value => value.type == 'namespace')[0]?.description ||
            // item.parent?.filter(value => value.type == 'namespace')[0]?.description ||
            // item.modules[0] ||
            // item.memberOf?.filter(value => value.type == 'module')[0]?.description ||
            // null,
            //-- Either Module, Type Description ( like file name, function name, etc), or NULL
            subGroup: item.modules[0] || item.type?.description || 'INVALID_SUB_GROUP', //TODO: verify this is correct.
            id: item.modules[0], //TODO: verify this is correct.
            active: false, // The overview is active by default.
          },
          children: [],
        }

        // 5.3. Update TabStripLinks array with tab.
        tabStripLinks.push(tabStripLink)
      }
    }) // End of building TabStripNavLink

    // 6. Update TabStripNavList (`ul`) with all tab-strip-nav-links (`li`).
    tabStripNavList.children.push(...tabStripLinks)

    // 7. Update TabStripNav (`nav`) with TabStripNavList (`ul`).
    TabStripNav.children.push(tabStripNavList)

    // 2.Executes TabStripNav's getChildren helper to populate all children within TabStripNav.
    // ( This executes steps 3 - 9. )
    // TabStripNav.children.push(...TabStripNav.helpers.getChildren())

    // 8. return the tab-strip-nav with links.
    return TabStripNav
  }

  /**
   *
   * @param parentId - The ID of the parent element to be used to get data to render content for.
   * @returns
   * @todo build this out to render content properly.
   * @todo determine if any defaults should exist.
   */
  buildGroupContent(
    parentItem: CommentsProcessed,
    group: string,
    parentId: string,
    ElementsProcessed: ElementsProcessed,
  ): Element[] {
    // 1. Container with at least the overview tab. to holder all content for namespace / file (should be module).
    const content_modulesInNamespace: Element[] = [
      // 2. Build the overview tab
      {
        id: parentItem.id,
        parent: ElementsProcessed.parents.contentWrapper,
        description: `Overview tab for namespace '${parentItem.namespaces[0]}'.`,
        elementType: 'div',
        classList: [
          'relative max-w-4xl mx-auto flex flex-col bg-white bg-opacity-60 overflow-auto w-full h-full py-6 px-4',
        ],
        content: [
          {
            type: 'OverviewTab',
          },
          parentItem?.summary ? parentItem?.summary : '',
          parentItem?.description ? parentItem?.description : '',
          // JSON.stringify(parentItem)
        ],
        dataAttributes: {
          value: null,
          type: parentItem.type?.type || parentItem.type?.description || null,
          path: parentItem.fileDetails.filePath,
          role: 'content', //-- Role of content when rendered to the UI.
          active: true,
          //-- Either Namespace or Module
          group:
            group ||
            parentItem.namespaces[0] ||
            parentItem.memberOf?.filter(value => value.type == 'namespace')[0]?.description ||
            parentItem.parent?.filter(value => value.type == 'namespace')[0]?.description ||
            parentItem.modules[0] ||
            parentItem.memberOf?.filter(value => value.type == 'module')[0]?.description ||
            null,
          //-- Either Module, Type Description ( like file name, function name, etc), or NULL
          subGroup: parentItem.modules[0] || parentItem.type?.description || null,
          id: parentItem.modules[0],
        },
        children: [],
      }, // end of overview tab declaration.
    ]

    // 3. Loop through processed data.
    this.processedData.map((item: CommentsProcessed) => {
      // 4. Get the children of the parent element. ( If Module is a member of the namespace. )
      if (item.parent.filter(parent => parent.id === parentId).length > 0) {
        // 5. Create the content for the module.
        const content: Element = {
          id: item.id,
          parent: ElementsProcessed.parents.contentWrapper || null,
          description: `Content for ${item.id} module within namespace ${parentId}.`,
          elementType: 'div',
          classList: [
            'relative max-w-4xl mx-auto flex flex-col bg-white bg-opacity-60 overflow-auto w-full h-full py-6 px-4',
            `hidden`, // hide content because all rendered in same parent.
          ],
          content: [
            item,
            // item.description || item.summary ||
          ],
          dataAttributes: {
            value: null,
            type: item.type?.type || item.type?.description || null,
            path: item.fileDetails.filePath,
            role: 'content', //-- Role of content when rendered to the UI.
            active: false,
            //-- Either Namespace or Module
            group:
              group ||
              item.namespaces[0] ||
              item.memberOf?.filter(value => value.type == 'namespace')[0]?.description ||
              item.parent?.filter(value => value.type == 'namespace')[0]?.description ||
              item.modules[0] ||
              item.memberOf?.filter(value => value.type == 'module')[0]?.description ||
              null,
            //-- Either Module, Type Description ( like file name, function name, etc), or NULL
            subGroup: item.modules[0] || item.type?.description || null,
            id: item.modules[0],
          },
          children: [],
        } // End of building element

        // 7. Push it into the content_modulesInNamespace array.
        content_modulesInNamespace.push(content)
      }
    }) // -- end of looping through processed data.

    // 8. return built elements.
    return content_modulesInNamespace
  }

  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //-- Helper Functions

  /**
   * @access private
   * @type {function} setContentGroups
   * @function setContentGroups
   * @memberof module:DocsToUi
   * @summary
   * * @description Returns all comments processed for root-items within comments,
   *  based on what the parent Content-Group definition is set as. Default is
   * `namespaces`. Data is being pulled and returned from `DocsToUi.contentGroups`.
   * @returns {boolean} True if successful, false if not.
   */
  getContentGroups(): CommentsProcessed[] | [] {
    try {
      //-- Get the root items
      const contentGroups = this.processedData?.filter((item: CommentsProcessed) => {
        if (
          // item.parent.length === 0 ||
          item.isRootItem == true
        ) {
          return item
        }
      })

      return contentGroups
    } catch (error) {
      console.error(error)
      return []
    }
  }

  /**
   * Get `CommentsProcessed[]`for members of the Content-Group.
   *
   * @function getContentGroupMembers
   * @type {function} getContentGroupMembers
   * @access private
   * @memberof module:DocsToUi
   * @summary Get `CommentsProcessed[]`for members of the Content-Group.
   * @description Define a valid content group id to get all processed comments
   * that are members of the defined Content-Group. Data is
   * @return {CommentsProcessed[] | []} - An array CommentsProcessed from `this.contentGroups` objects if any defined.
   */
  getContentGroupMembers(contentGroupId: string): CommentsProcessed[] | [] {
    try {
      if (!contentGroupId) throw new Error(`ERROR: No content group id defined.`)
      //-- Get all members of the content group.

      const contentGroupMembers = this.processedData?.filter((item: CommentsProcessed) => {
        if (
          item &&
          item.memberOf != undefined &&
          item.memberOf.filter(
            //TODO: 2023-07-23 | Erik Plachta | Convert from any to proper once verified.
            (parent: any) => {
              if (parent.id === contentGroupId) {
                return parent
              }
            },
          ).length > 0
        ) {
          return item
        }
      })

      return contentGroupMembers
    } catch (error) {
      console.error(error)
      this.errors.push({
        id: randomUUID(),
        type: 'warning',
        message: `ERROR: Failed to get content group members for content group id: ${JSON.stringify(contentGroupId)}.`,
        data: error,
      })
      return []
    }
  }

  /**
   *
   * @param {string} parentId - The `id` of the processed comment.
   * @returns
   */
  getItemsByParent(parentId: string): CommentsProcessed[] | undefined | boolean {
    try {
      //-- Get the root items
      const items = this.processedData?.filter((item: CommentsProcessed) => {
        if (item.parent.length > 0) {
          item.parent.map(parent => {
            if (parent.id === item.id) {
              return item
            }
          })
        }
      })

      return items
    } catch (error) {
      console.error(error)
      return false
    }
  }

  //----------------------------------------------------------------------------
  //----------------------------------------------------------------------------
  //-- Actually rendering UI content, here.

  async getHtml(): Promise<string> {
    const html = new BuildHtml(this.LogLevel, this.elements, this.title, this.htmlConfig)
    return await html.build()
  }

  /**
   * Convert the data to Markdown
   * @return {string} The Markdown string
   * @todo Implement the method
   */
  getMarkdown(): string {
    // Implement the method as before...
    return 'NOT_IMPLEMENTED'
  }
}

module.exports = DocsToUi
