/**
 * @file index.ts - Contains class for converting JSON data generated by BuildDocs module into markdown and/or HTML.
 * @access private
 * @namespace {build-docs.JsonToUi}
 * @module JsonToUi
 * @memberof namespace:build-docs
 * @changelog 0.0.2 | 2023-07-14 | Erik Plachta | Built out more complete data extraction
 */

import { DataItem, ProcessedDataItem, Namespace, Module, DataToRender} from "../types";
import { randomUUID } from 'crypto'

/**
 * @access private
 * @memberof module:JsonToUi
 * @memberof namespace:build-docs.JsonToUi
 * @classdesc Converting JSON data generated by BuildDocs module into markdown and/or HTML.
 */
/**
 * Class to convert JSON data to Markdown and HTML
 */
class JsonToUi {
	data: DataItem[];
	files: string[]; //TODO: Add files or remove this.
	namespaces: Namespace[];
	modules: Module[];
	processedData: ProcessedDataItem[] | undefined;
	rootItems: ProcessedDataItem[] | undefined | boolean;
	elements: {
		id: string,
		processedItemId: ProcessedDataItem['id'],
		dataToRender: DataToRender
	}[];

	/**
	 * @param {DataItem[]} data - The JSON data to convert
	 */
	constructor(data: DataItem[]) {
		this.data = data;
		this.files = [];
		this.namespaces = [];
		this.modules = [];
		this.processedData = this.processData(data);
		this.rootItems = this.getRootItems();
		this.elements = this.buildElements();
	}

	//----------------------------------------------------------------------------
	/**
	 * Process data for easier use
	 * @param {DataItem[]} data - The data to process
	 * @return {ProcessedDataItem[]} The processed data
	 */
	processData(data: DataItem[]): ProcessedDataItem[] 
	{
		const processedData: ProcessedDataItem[] = [];

		//-----------------------------
		// 1. First pass through all items to extract individual doc info.
		data.map((item: DataItem) => {
			processedData.push({
				id: item.id,

				fileDetails: {
					fileName: item.fileName,
					filePath: item.filePath,
					createdDate: item.createdDate,
					modifiedDate: item.modifiedDate,
				},

				type: item.doc?.type?.[0]?.description
					? {
							type: item.doc?.type?.[0]?.description
								.split("}")[0]
								.replace("{", ""),
							description: item.doc?.type?.[0]?.description
								.split("}")[1]
								.trim(),
					  }
					: null,

				version: item.doc?.version?.[0]?.description
					? item.doc?.version?.[0]?.description
					: null,

				author: item.doc?.author?.[0]?.description
					? item.doc?.author?.[0]?.description
					: null,

				access: item.doc?.access?.[0]?.description
					? item.doc?.access?.[0]?.description
					: null,

				description: item.doc?.description?.[0]?.description
					? item.doc?.description?.[0]?.description
					: null,

				summary: item.doc?.summary?.[0]?.description
					? item.doc?.summary?.[0]?.description
					: null,

				param:
					item.doc?.param?.length > 0
						? item.doc.param.forEach((param) => {
								return {
									type: "",
									name: param?.description || "",
									description: param?.description || "",
								};
						  })
						: [],

				argument:
					item.doc?.argument?.length > 0
						? item.doc?.argument.map((argument) => {
								const args = argument.description.match(/(\{[^}]*\}|\[[^\]]*\]|`[^`]*`|[^ ]+)/g);
								const [type, name, ...description] = args || [];

								return {
									type: type?.replace("{", "").replace("}", "") || '',
									name: name?.replace("[", "").replace("]", "") || '',
									description: description?.join(" ").replace("-","") || ''
								};
						  })
						: [],

				changelog:
					item.doc?.changelog?.length > 0
						? item.doc?.changelog.map((changelog) => {
								return changelog?.description;
						  })
						: [],

				todo:
					item.doc?.todo?.length > 0
						? item.doc?.todo.map((todo) => {
								return todo?.description;
						  })
						: [],

				bug:
					item.doc?.bug?.length > 0
						? item.doc?.bug.map((bug) => {
								return bug?.description;
						  })
						: [],

				example:
					item.doc?.example?.length > 0
						? item.doc?.example.map((example) => {
								return example?.description;
						  })
						: [],

				//-----------------------------
				//-- Creating empty values for the below, which will be populated on next pass.
				parentId: [],
				childrenId: [],

				//-----------------------------
				//-- Extract description from comment for namespace(s)
				namespaces:
					item.doc?.namespace?.length > 0
						? item.doc?.namespace.map((namespace) => {
								const value = namespace?.description
									.replace("{", "")
									.replace("}", "");
								this.namespaces.push({ id: item.id, value: value });
								return value;
						  })
						: [],

				//-----------------------------
				//-- Extract description from comment for module(s)
				modules:
					item.doc?.module?.length > 0
						? item.doc?.module.map((thisModule) => {
								const value = thisModule.description;
								this.modules.push({ id: item.id, value: value });
								return value;
						  })
						: [],

				//-----------------------------
				memberOf:
					item.doc?.memberof?.length > 0
						? item.doc?.memberof.map((memberof) => {
								const value = memberof?.description.split(":");
								return {
									type: value[0],
									value: value[1],
								};
						  })
						: [],

				requires: item.doc?.requires?.length > 0
				 ? item.doc?.requires.map((requires) => {
						return { description: requires?.description || ''}
					})
				 : [],
			});
		});

		//-- Second  pass to add associations between items, recording files, etc
		processedData.map((item: ProcessedDataItem) => {

			//-----------------------------
			//-- If the item has a memberOf, then it is a child of another item.
			if (item?.memberOf && item?.memberOf?.length > 0) {
				item.memberOf.map((memberOf) => {
					//-- Assign relationships for namespaces
					if (memberOf.type === "namespace") {
						this.namespaces.map((thisNamespace) => {
							if (thisNamespace.value === memberOf.value) {
								//-- Add the parent id as the parent to the children
								item.parentId.push(thisNamespace.id);

								//-- Find the parent and assign the child id to it
								processedData.map((parentItem: ProcessedDataItem) => {
									if (parentItem.id === thisNamespace.id) {
										parentItem.childrenId.push(item.id);
									}
								});
							} else {
								// console.log('thisNamespace.value, memberOf.value', thisNamespace.value, memberOf.value)
								const allMemberValues = memberOf?.value.split(" | ") || [];
								// const match = allMemberValues.filter((value) => { value === thisNamespace.value })
								const allNamespaceValues =
									thisNamespace.value.split(" | ") || [];
								// const match = allNamespaceValues.filter((value) => { value === memberOf.value })
								if (item.fileDetails.filePath == "src/index.js") {
									console.log("allMemberValues: ", allMemberValues);
									console.log("allNamespaceValues: ", allNamespaceValues);
									// console.log("match: ", match)
								}
							}
						});
					}

					//-- Assign relationships for modules when relevant
					if (memberOf.type === "module") {
						//-- Loop through all modules, check to see if the item is a member of the module.
						this.modules.map((thisModule) => {
							if (thisModule.value === memberOf.value) {
								//-- Add the parent id as the parent to the children
								item.parentId.push(thisModule.id);

								//-- Find the parent and assign the child id to it
								processedData.map((parentItem: ProcessedDataItem) => {
									if (parentItem.id === thisModule.id) {
										parentItem.childrenId.push(item.id);
									}
								});
							}
						}); // end of checking match for module names
					} //-- end of checking if memberOf.type === 'module'
				}); //-- end of looping through all memberOf
			} //-- end of checking if item.memberOf.length > 0
		}); //-- end of looping through all processedData
		return processedData;
	}
	//----------------------------------------------------------------------------

	/**
	 * Evaluate all processed data, and generate file hierarchy.
	 *
	 * @returns {boolean} True if successful, false if not.
	 */
	getRootItems(): ProcessedDataItem[] | undefined | boolean {
		try {
			//-- Get the root items
			const rootItems = this.processedData?.filter((item) => {
				return item.parentId.length === 0;
			});
			return rootItems;
		} catch (error) {
			console.error(error);
			return false;
		}
	}

	//----------------------------------------------------------------------------
	//-- 
	
	/**
	 * 
	 * @return {array[object]} - An array of objects, each containing the id of the element, the id of the processed item it relates to, and the data to render.
	 */
	buildElements(): { id: string, processedItemId: string, dataToRender: DataToRender}[] {
		
		return [
			{
				id: randomUUID(),
				processedItemId: 'id-value',
				dataToRender: {
					type: 'type-value',
					value: 'value-value',
					dataSets: {
						role: 'role-value',
						group: 'group-value',
						subGroup: 'subGroup-value',
						id: 'id-value',
					}	
				}
			}
		]
	}

	//----------------------------------------------------------------------------
	/**
	 * Convert the data to Markdown
	 * @return {string} The Markdown string
	 * @todo Implement the method
	 */
	toMarkdown(): string {
		// Implement the method as before...
		return "";
	}

	/**
	 * Convert the data to HTML
	 * @return {string} The HTML string
	 * @todo Implement the method
	 */
	toHtml(
		title = "Placeholder Title",
		subTitle = "Placeholder subtitle for html."
	): string {
		return `${title} ${subTitle}`;
		// const bodyStart = `<html>
		//         <head>
		//             <title>${title}</title>
		//             <meta charset="utf-8" />
		//             <meta name="viewport" content="width=device-width, initial-scale=1" />
		//             <script src="https://cdn.tailwindcss.com"></script>
		//         </head>
		//         <body class="bg-gray-100 flex flex-col gap-8">`;

		// const getMainNav = ""; //todo: build this out

		// const buildHeader = `<header class="w-full p-0 m-0 px-4 pt-4 border-solid border-2 bg-white flex flex-col gap-4 max-w-8xl mx-auto">
		// 		<div class="max-w-4xl mx-auto w-full">
		// 				<h1 class="text-blue-500 text-4xl">
		// 						${title}
		// 				</h1>
		// 				<p class="text-gray-400">
		// 						${subTitle}
		// 				</p>
		// 		</div>
		// 		<nav>
		// 			<ul class="flex flex-row gap-6 mt-auto h-full">
		// 					<li class="py-2 px-4 border-solid border-b-4 border-blue-500 hover:border-blue-500/80"
		// 							data-role="nav-main"
		// 							data-group="overview"
		// 					>
		// 							<a href="#overview">Overview</a>
		// 				</li>` +
		// 		getMainNav() +
		// 		`</ul>
		// 		</nav>
		// 	</header>`
		// ;
	}
}

module.exports = JsonToUi;
