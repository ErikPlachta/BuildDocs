/**
 * @access private
 * @file JsonToUi\index.ts
 * @summary Contains class for converting JSON data generated by BuildDocs module into markdown and/or HTML.
 * @namespace {build-docs.JsonToUi}
 * @module JsonToUi
 * @memberof namespace:build-docs
 * @requires module:BuildHtml
 * @fires module:BuildHtml
 * @changelog 0.0.1 | 2023-07-13 | Erik Plachta | Initial version
 * @changelog 0.0.2 | 2023-07-14 | Erik Plachta | Built out more complete data extraction
 * @changelog 0.0.3 | 2023-07-15 | Erik Plachta | Finalized data extraction for building HTML. Add files,
 * @changelog 0.0.4 | 2023-07-21 | Erik Plachta | Finalized concept for ElementsProcessed.
 * @changelog 0.0.5 | 2023-07-22 | Erik Plachta | Created module BuildHtml and verified finalized concept html generation.
 *
 * @todo 2023-07-15 | Erik Plachta | Add more complete config options
 * @todo 2023-07-15 | Erik Plachta | Add markdown generation
 */

import { randomUUID } from 'crypto' // Generate unique IDs for elements.

import {
  Comments, //-- Comments built by DocsToJson, ready to be processed.
  CommentsProcessed,
  Namespace,
  Module,
  File,
  JsonToUiConfig,
  Element,
  Elements,
  ElementsProcessed,
  htmlConfig,
  Logging
} from '../types'

import BuildHtml from './lib/BuildHtml'

/**
 * Converting JSON data generated by BuildDocs module into markdown and/or HTML.
 *
 * @access private
 * @class
 * @memberof module:JsonToUi
 * @summary Converting JSON data generated by BuildDocs module into markdown and/or HTML.
 * @param {DataItem[]} data - The JSON data to convert
 * @param {Config} config - The configuration for the conversion
 */
class JsonToUi {
  public config: JsonToUiConfig
  public comments: Comments[]
  private LogLevel: Logging['option']['level']['value']
  public files: File[]
  public namespaces: Namespace[]
  public modules: Module[]
  public processedData: CommentsProcessed[] | []
  public rootItems: CommentsProcessed[] | []
  public elements: ElementsProcessed

  public title: string
  public htmlConfig: htmlConfig
  // public getHtml: () => Promise<string | undefined> 
  // public getHtml: () => Promise<string>

  //-----------

  /**
   * @constructor
   * @access public
   * @memberof module:JsonToUi
   * @param {Logging['option']['level']['value']} LogLevel - The log level to use.
   * @param {Comments[]} comments - The JSON data object containing all comment info to converted.
   * @param {Config} config - The configuration for the conversion.
   */
  constructor(
    LogLevel: Logging['option']['level']['value'],
    comments: Comments[],
    config: { convertToMarkdown: boolean; convertToHtml: boolean },
  ) {
    this.comments = comments
    this.config = config
    this.LogLevel = LogLevel
    this.files = []
    this.namespaces = []
    this.modules = []
    this.processedData = this.processComments(comments)

    //-- All top-level items that represent a group of info. (Ex, the file that contains a class, functions, etc)
    this.rootItems = this.getRootItems()
    //-- Evaluate `this.processedData` and `this.rootItems`, assign `ContentToRender` values.
    this.elements = this.buildElements()

    this.title = 'JsonToUi'
    this.htmlConfig = {
      html: {
        lang: 'en',
      },
      head: {
        meta: [
          {
            type: 'viewport',
            value: 'width=device-width, initial-scale=1.0',
          },
          {
            type: 'charset',
            value: 'utf-8',
          },
        ],
        scripts: [
          {
            src: 'https://cdn.tailwindcss.com',
          },
        ],
        styles: [],
      },
      body: {
        classList: ['bg-gray-100', 'flex', 'flex-col', 'gap-8'],
        styles: [],
      },
    }
  }
  //----------------------------------------------------------------------------
  /**
   * Process data for easier use
   * @param {Comments[]} comments - The data to process
   * @return {CommentsProcessed[]} The processed data
   * @todo 2013-07-18 | Erik Plachta | Move into DocsToJson module from here.
   */
  processComments(comments: Comments[]): CommentsProcessed[] {
    const processedData: CommentsProcessed[] = []

    //-----------------------------
    // 1. First pass through all items to extract individual doc info.
    comments &&
    comments.map((item: Comments) => {
      processedData.push({
        id: item.id,

        //-- if it's got a namespace it's a root item.
        isRootItem: item.comments?.namespace?.[0]?.description ? true : false,

        fileDetails: {
          //-- All return this even if it's not a file because it's relational reference.
          fileName: item.fileName,
          filePath: item.filePath,
          createdDate: item.createdDate,
          modifiedDate: item.modifiedDate,
        },

        type: item.comments?.type?.[0]?.description
          ? {
              type: item.comments?.type?.[0]?.description.split('}')[0].replace('{', ''),
              description: item.comments?.type?.[0]?.description.split('}')[1].trim(),
            }
          : item.comments?.file?.[0]?.description
          ? {
              type: 'file',
              description: item.comments?.file?.[0]?.description,
            }
          : null,

        version: item.comments?.version?.[0]?.description ? item.comments?.version?.[0]?.description : null,

        author: item.comments?.author?.[0]?.description ? item.comments?.author?.[0]?.description : null,

        access: item.comments?.access?.[0]?.description ? item.comments?.access?.[0]?.description : null,

        description: item.comments?.description?.[0]?.description ? item.comments?.description?.[0]?.description : null,

        summary: item.comments?.summary?.[0]?.description ? item.comments?.summary?.[0]?.description : null,

        props:
          item.comments?.param?.length > 0
            ? item.comments.param.map(param => {
                const args = param.description.match(/(\{[^}]*\}|\[[^\]]*\]|`[^`]*`|[^ ]+)/g)
                const [type, name, ...description] = args || []

                return {
                  id: item.id,
                  type: type?.replace('{', '').replace('}', '') || null,
                  name: name?.replace('[', '').replace(']', '') || null,
                  description: description?.join(' ').replace('-', '') || null,
                }
              })
            : [],

        arguments:
          item.comments?.argument?.length > 0
            ? item.comments?.argument.map(argument => {
                const args = argument.description.match(/(\{[^}]*\}|\[[^\]]*\]|`[^`]*`|[^ ]+)/g)
                const [type, name, ...description] = args || []

                return {
                  id: item.id,
                  type: type?.replace('{', '').replace('}', '') || '',
                  name: name?.replace('[', '').replace(']', '') || '',
                  description: description?.join(' ').replace('-', '') || '',
                }
              })
            : [],

        changelog:
          item.comments?.changelog?.length > 0
            ? item.comments?.changelog.map(changelog => {
                return changelog?.description
              })
            : [],

        todo:
          item.comments?.todo?.length > 0
            ? item.comments?.todo.map(todo => {
                return todo?.description
              })
            : [],

        bug:
          item.comments?.bug?.length > 0
            ? item.comments?.bug.map(bug => {
                return bug?.description
              })
            : [],

        example:
          item.comments?.example?.length > 0
            ? item.comments?.example.map(example => {
                return example?.description
              })
            : [],

        //-----------------------------
        //-- Creating empty values for the below, which will be populated on next pass.
        parent: [],
        children: [],
        related: [],

        //-----------------------------
        //-- Extract description from comment for namespace(s)
        namespaces:
          item.comments?.namespace?.length > 0
            ? item.comments?.namespace.map(namespace => {
                //-- Cleanup description to prepare to record
                const description = namespace?.description.replace('{', '').replace('}', '')

                //-- Record namespace if isn't already defined in global state.
                // ( Should never create duplicates either way, but just in case. )
                if (this.namespaces.filter(item => description !== item.description)) {
                  this.namespaces.push({
                    id: item.id,
                    description: description,
                  })
                }

                //-- return object for the item itself as a value for the `namespaces` property.
                return description
              })
            : [],

        //-----------------------------
        //-- Extract description from comment for module(s)
        modules:
          item.comments?.module?.length > 0
            ? item.comments?.module.map(thisModule => {
                const value = thisModule.description
                this.modules.push({
                  id: item.id,
                  description: value,
                })
                return value
              })
            : [],

        //-----------------------------
        memberOf:
          item.comments?.memberof?.length > 0
            ? item.comments?.memberof.map(memberof => {
                const value = memberof?.description.split(':')
                return {
                  type: value[0],
                  description: value[1],
                }
              })
            : [],

        requires:
          item.comments?.requires?.length > 0
            ? item.comments?.requires.map(require => {
                const rootDesc = require.description
                const { type, name, description } = rootDesc.includes('https://nodejs.org/api')
                  ? //-- Node Module
                    {
                      type: 'node-module',
                      name: rootDesc.split(' | ')[1]?.replace('}', ''),
                      description: rootDesc.split('{@link ')[1]?.split(' | ')[0],
                    }
                  : rootDesc.split(':')[0].includes('module')
                  ? //-- Custom Module
                    {
                      // id: item?.id || null,
                      type: rootDesc.split(':')[0],
                      name: rootDesc.split(':')[1],
                      description: rootDesc.split(':')[1],
                    }
                  : //-- Everything else that isn't programmed in yet.
                    {
                      // id: item?.id || null,
                      type: 'unknown', //TODO: update this
                      name: null,
                      description: rootDesc,
                    }
                return {
                  id: item.id,
                  type: type || null,
                  name: name || null,
                  description: description || null,
                }
              })
            : [],
      })
    })

    // 2. Second  pass to add associations between items, recording files, etc
    processedData.map((item: CommentsProcessed) => {
      // 2.1. if has an @memberof tagging.
      if (item?.memberOf && item?.memberOf?.length > 0) {
        item.memberOf.map(memberOf => {
          //-----------------
          // 1.1 Assign relationships for namespaces
          if (memberOf.type === 'namespace') {
            this.namespaces.map(thisNamespace => {
              if (thisNamespace.description === memberOf.description) {
                //-- Add the parent id as the parent to the children
                item.parent.push({
                  id: thisNamespace.id,
                  type: item?.type?.type || null,
                  association: 'namespace',
                  description: thisNamespace.description,
                })
              } else {
                //TODO: onboard or remove this logic.
                // console.log('thisNamespace.value, memberOf.value', thisNamespace.value, memberOf.value)
                const allMemberValues = memberOf?.description.split(' | ') || []
                // const match = allMemberValues.filter((value) => { value === thisNamespace.value })
                const allNamespaceValues = thisNamespace.description.split(' | ') || []
                // const match = allNamespaceValues.filter((value) => { value === memberOf.value })
              }
            })
          }

          //-----------------
          // 1.2. Assign relationships for modules
          if (memberOf.type === 'module') {
            //-- Loop through all modules, check to see if the item is a member of the module.
            this.modules.map(thisModule => {
              if (thisModule.description === memberOf.description) {
                //-- Add the parent id as the parent to the children
                item.parent.push({
                  id: thisModule.id,
                  type: item?.type?.type || null,
                  association: 'module',
                  description: thisModule.description,
                })

                //-- Find the parent and assign the child id to it
                processedData.map((parentItem: CommentsProcessed) => {
                  if (parentItem.id === thisModule.id) {
                    parentItem.children.push({
                      id: item.id,
                      type: item.type?.type || null,
                      association: 'module',
                      description: thisModule.description,
                    })
                  }
                }) // end of adding children associations for parent members of modules
              } // end of module names match
            }) // end of checking match for module names
          } //-- end of checking if memberOf.type === 'module'
        }) //-- end of looping through all memberOf
      } //-- end of checking if item.memberOf.length > 0

      //------------------------------------------------------------------
      // 2.2 If item is a file append this.files array. (children added after this loop)
      if (
        item.type?.type &&
        item.type.type == 'file' &&
        item.type?.description &&
        item.type?.description != (undefined || null)
      ) {
        this.files.push({
          id: item.id,
          description: item.type.description,
          filePath: item.fileDetails.filePath,
        })
      }
    }) //-- end of looping through all processedData

    // 3. If item is NOT a Root Item, add it's parent file to the files parent array.
    processedData.map((item: CommentsProcessed) => {
      if (item?.isRootItem != true) {
        // 3.1 If item is NOT a Root Item, add it's parent file to the files parent array.
        this.files.map(file => {
          if (file.filePath === item.fileDetails.filePath) {
            item.parent.push({
              id: file.id,
              type: item?.type?.type || null,
              association: 'file',
              description: file.description,
            })
          }
          // 3.2 Make sure proper parent association
          else {
            let fileToUpdate: any = processedData.filter(CommentsProcessed => {
              CommentsProcessed.id === file.id
            })
            //-- If there is a file, and there is not already an entry for it, add it.
            if (fileToUpdate.children && fileToUpdate.children.filter((child: any) => child.id !== item.id)) {
              fileToUpdate.children.push({
                id: item.id,
                type: 'file',
                description: file.description,
              })
            }
          }
        })
      }
    }) //-- end of looping through all processedData

    return processedData
  }

  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //-- Building Content associations based on processed results:

  /**
   * @access private
   * @type {function} getRootItems
   * @function getRootItems
   * @memberof module:JsonToUi
   * @summary Take `this.rootItems` and build `ContentToRender` object.
   * @returns {boolean} True if successful, false if not.
   */
  getRootItems(): CommentsProcessed[] | [] {
    try {
      //-- Get the root items
      const rootItems = this.processedData?.filter((item: CommentsProcessed) => {
        if (
          // item.parent.length === 0 ||
          item.isRootItem == true
        ) {
          return item
        }
      })

      return rootItems
    } catch (error) {
      console.error(error)
      return []
    }
  }

  getItemsByParent(parent: string): CommentsProcessed[] | undefined | boolean {
    try {
      //-- Get the root items
      const items = this.processedData?.filter((item: CommentsProcessed) => {
        if (item.parent.length > 0) {
          item.parent.map(parent => {
            if (parent.id === item.id) {
              return item
            }
          })
        }
      })

      return items
    } catch (error) {
      console.error(error)
      return false
    }
  }

  //----------------------------------------------------------------------------
  //----------------------------------------------------------------------------
  //-- Building actual objects based on what UI content needs.

  /**
   * This function is the main function that generates the `this.elements` object.
   *
   * 1. Create an array to hold the Element and all related info to be generated.
   * 2. Executes this.buildHeader() to get Elements Processed for the Main Nav component.
   * 3. Executes this.buildGroupContentWrapper() to get Elements Processed for the Content Wrapper component.
   *
   * @access private
   * @type {function} buildElements
   * @function buildElements
   * @memberof module:JsonToUi
   * @summary Manages parsing Processed Data and builds `this.elements`.
   * @description This function is the main function that generates the `this.elements` object.
   * @returns {boolean} True if successful, false if not.
   * @fires buildHeader
   * @fires buildGroupContentWrapper
   * @return {array[object]} - An array of objects, each containing the id of the element, the id of the processed item it relates to, and the data to render.
   *
   * @todo  2023-07-20 | Erik Plachta | Onboard helper functions
   */
  buildElements(): ElementsProcessed {
    //-- Define IDs for the top-level elements.
    const parentIds = {
      body: randomUUID(),
      header: randomUUID(),
      navHeader: randomUUID(),
      navHeaderList: randomUUID(),
      main: randomUUID(),
      contentWrapper: randomUUID(),
      footer: randomUUID(),
    }

    // 1. Create an array to hold the Element and all related info to be generated.
    let ElementsProcessed: ElementsProcessed = {
      id: randomUUID(),
      createdDate: new Date(),

      description:
        'Top-level wrapper around all elements. Root consists of Body, Header, Main, Footer, and all children are rendered within.',
      parents: { ...parentIds },
      HtmlElements: [ 
        {
          id: parentIds.body,
          createdDate: new Date(),
          title: 'body',
          description: 'The body wrapping all content.',
          parents: { ...parentIds },
          Elements: [
            {
              id: parentIds.footer,
              orderId: 99,
              parent: null,
              //TODO: Add footer content
              description: 'Footer within the rendered content.',
              elementType: 'footer',
              classList: [],
              dataAttributes: {
                value: 'Footer Placeholder Text',
                type: null,
                path: null,
                role: 'footer',
                group: null,
                subGroup: null,
                id: null,
                active: null,
              },
              children: [],
              helpers: { getChildren: () => [] },
            },
          ],
        },
      ],
      helpers: {
        //TODO: 2023-07-20 | Erik Plachta | Onboard these helper functions
        getElements: () => [],
        getElementById: (id: string) => [],
        getElementsById: (id: string) => [],
        getElementsByParentId: (parent: string) => [],
        getElementsByRole: (role: string) => [],
        getElementsByGroup: (group: string) => [],
        getElementsBySubGroup: (subGroup: string) => [],
        getElementsByType: (type: string) => [],
      },
    } // end of base declaration.

    // 3. Build the Main navigation, one link for each namespace.
    ElementsProcessed = ElementsProcessed = this.buildHeader(ElementsProcessed)
    // ElementsProcessed.HtmlElements.push(...header.HtmlElements)
    // 4. Build Content Wrapper, Tab-Strip-Nav, and Content for each namespace.
    ElementsProcessed = this.buildGroupContentWrapper(ElementsProcessed)
    // ElementsProcessed.HtmlElements.push(...contentWrapper.HtmlElements)


    // console.log('ElementsProcessed: ', ElementsProcessed)

    // 5. Returns finalized ElementsProcessed object.
    return ElementsProcessed
  }

  //-------------------------------
  //-- Utilities used by buildElements

  /**
   * Extracts namespaces from the processed data, creates main nav elements for each.
   * @access private
   * @type {function} buildHeader
   * @function buildHeader
   * @param {object} ElementsProcessed - The object containing all elements to be rendered.
   * @return {object} ElementsProcessed - The object containing all elements to be rendered.
   */
  buildHeader(ElementsProcessed: ElementsProcessed): ElementsProcessed {
    const header: Elements = {
      id: ElementsProcessed.parents.header, //-- The ID of the raw json data all content is being rendered from.
      title: 'header',
      description: 'Header element for the page. Contains the main navigation.',
      createdDate: new Date(),
      parents: { ...ElementsProcessed.parents },
      Elements: [
        {
          id: ElementsProcessed.parents.header,
          orderId: 2,
          parent: null,
          description: 'Header element for the page. Contains the main navigation.',
          elementType: 'header',
          classList: ['w-full p-0 m-0 px-4 pt-4 border-solid border-2 bg-white flex flex-col gap-4 max-w-8xl mx-auto'],
          dataAttributes: {
            value: null,
            type: null,
            path: null,
            role: 'header',
            group: null,
            subGroup: null,
            id: null,
            active: null,
          },
          children: [],
          helpers: {
            getChildren: () => {
              const NavHeader: Element = {
                id: ElementsProcessed.parents.header,
                parent: ElementsProcessed.parents.navHeader,
                description:
                  "Nav container holding the nav element and it's children within content-wrapper for group.",
                elementType: 'nav',
                classList: ['max-w-4xl mx-auto w-full px-4 pt-4'],
                dataAttributes: {
                  value: null,
                  type: null,
                  path: null,
                  role: 'nav-header',
                  group: ElementsProcessed.parents.navHeader,
                  subGroup: null,
                  id: 'nav-header',
                  active: false,
                },
                children: [],
                helpers: {
                  getChildren: () => {
                    // 3. Build the UL to hold the nav links.

                    const NavHeaderList: Element = {
                      id: ElementsProcessed.parents.navHeaderList,
                      parent: ElementsProcessed.parents.navHeader,
                      description: `Main navigation list, holding a link for each namespace.`,
                      elementType: 'ul',
                      classList: ['flex flex-row gap-6 mt-auto h-full'],
                      dataAttributes: {
                        value: null,
                        type: null,
                        path: null,
                        role: 'nav-header-list', //-- Role of content when rendered to the UI.
                        group: null,
                        subGroup: null,
                        id: null,
                        active: null, // -- not relevant for ul.
                      },
                      children: [],
                      helpers: { getChildren: () => [] },
                    } // end of base UL to hold LIs.

                    // 4. Get all Namespaces and create main nav elements for them.
                    let itemCount = 0 // Used to set the first item as active within elements being processed.
                    this.rootItems.map((item: CommentsProcessed) => {
                      if (item.namespaces.length > 0) {
                        // 2. Create the main nav elements for each namespace.
                        const NavHeaderLink: Element = {
                          id: item.id,
                          parent: ElementsProcessed.parents.navHeaderList,
                          description:
                            item.description ||
                            item.summary ||
                            `Link within the tab-strip-nav-list for for module '${item.modules[0]}' within namespace '${item.namespaces[0]}'.`,
                          elementType: 'li',
                          classList: ['py-2 px-4 border-solid border-b-4 border-blue-500 hover:border-blue-500/80'],
                          dataAttributes: {
                            value:
                              item.namespaces[0]?.toUpperCase() ||
                              item.modules[0]?.toUpperCase() ||
                              item.type?.description ||
                              'no-value-set',
                            type: item.type?.type || item.type?.description || null,
                            path: item.fileDetails.filePath,
                            role: 'nav-header-link', //-- Role of content when rendered to the UI.
                            group: item.namespaces[0], //-- Used to target content to make visible.
                            subGroup: null, //-- none at this level. // TODO: Verify this is correct.
                            id: item.namespaces[0], //-- Unique ID to connect tab-strip-nav to it's related content to display. For example, `overview-summary` is the id for the overview tab and the overview content.
                            active: itemCount === 0 ? true : false, //-- Used to determine if the content should be visible or not.
                          },
                          children: [],
                          helpers: { getChildren: () => [] },
                        } // end of navHeaderList declaration.

                        //-- Increment the item count to make sure only first item is active.
                        itemCount++

                        // 3. Add the nav link to the navHeader object if it's defined.
                        NavHeaderList.children.push(NavHeaderLink)
                      }
                    }) // -- end of making links for namespaces.

                    // 6. Return the UL with all the nav links as children to the nav.
                    return [NavHeaderList]
                  },
                },
              }

              // Render children for NavHeader
              NavHeader.children.push(...NavHeader.helpers.getChildren())

              return [NavHeader]
            },
          },
        },
      ],
    } // end of base UL to hold LIs.

    // 2. Get all within Nav-Header and Nav-Header-Links.
    if (header.Elements != undefined) {
      header.Elements[0].children.push(...header.Elements[0].helpers.getChildren())
    }

    // 4. Add the main navigation UL and children LIs to the ElementsProcessed object.
    ElementsProcessed.HtmlElements.push(header)

    // 5. Return updated object with the main nav elements within.
    return ElementsProcessed
  }

  //-------------------------------------
  //-- Build Content Wrapper, Tab-Strip-Nav, and Content for each namespace.

  /**
   * For each namespace, creates a content wrapper, tab-strip-nav, and content.
   *
   * @access private
   * @type {function} buildGroupContentWrapper
   * @function buildGroupContentWrapper
   * @param {object} ElementsProcessed - The object containing all elements to be rendered.
   * @return {object} ElementsProcessed - The object containing all elements to be rendered.
   * @summary Evaluates namespaces and creates content to be built into main.
   * @description For each namespace, creates a content wrapper, tab-strip-nav, and content.
   * @fires buildTabStripNav
   * @fires buildContent
   *
   * @todo 2023-07-20 | Erik Plachta | Add logic to build default tab for overview
   */
  buildGroupContentWrapper(ElementsProcessed: ElementsProcessed): ElementsProcessed {
    //TODO: 2023-07-20 | Erik Plachta | Add logic to build default tab for overview, too.

    //-- Create IDs here to use in the Group-Content-Wrapper, so can pass down as parents.
    const tabStripNavId = randomUUID()
    const tabStripNavListId = randomUUID()

    // 1. Get all Namespaces and create main nav elements for them.
    this.rootItems.map((item: CommentsProcessed) => {
      if (item.namespaces.length > 0) {
        // 2. Create the main nav elements for each namespace.
        const rootElementToRender: Elements = {
          id: item.id, //-- The ID of the raw json data all content is being rendered from.
          createdDate: new Date(),
          title: `group-content-wrapper-${item.namespaces[0]}`,
          description: `Holds all elements for the namespace: ${item.namespaces[0]}.`,
          parents: {
            ...ElementsProcessed.parents,
            container: item.id,
            tabStripNav: tabStripNavId,
            tabStripNavList: tabStripNavListId,
          },
          Elements: [
            {
              id: item.id,
              orderId: 3,
              parent: ElementsProcessed.parents.main,
              description: `Div within 'main' for Group (namespace) '${item.namespaces[0]}'. Holds the tab-strip-nav and all GroupContentWrapper (which holds GroupContent).`,
              elementType: 'div',
              classList: [
                'relative max-w-4xl mx-auto flex flex-col bg-white bg-opacity-60 overflow-auto w-full h-full',
              ],
              dataAttributes: {
                value: null,
                type: null,
                path: null,
                role: 'group-content-wrapper',
                group: item.namespaces[0],
                subGroup: null,
                id: item.namespaces[0], //-- Unique ID to connect tab-strip-nav to it's related content to display. For example, `overview-summary` is the id for the overview tab and the overview content.
                active: false,
              },
              children: [],
              helpers: {
                // 2. Build the content and it's children
                getChildren: () => {
                  const GroupContent: Element = {
                    id: randomUUID(),
                    parent: item.id,
                    description: `Wrapper to hold content within group-content-wrapper, for group (namespace) '${item.namespaces[0]}'.`,
                    elementType: 'div',
                    classList: ['border-solid border-2 rounded-b-xl h-full p-4'],
                    dataAttributes: {
                      value: null,
                      type: null,
                      path: null,
                      role: 'group-content',
                      group: item.namespaces[0],
                      subGroup: null,
                      id: null,
                      active: false,
                    },
                    children: [],
                    helpers: {
                      getChildren: () => {
                        return this.buildGroupContent(item.namespaces[0], item.id, ElementsProcessed)
                      },
                    },
                  }

                  // 3. Build the tab strip nav and it's children
                  const tabStripNav: Element = this.buildTabStripNav(
                    item.namespaces[0],
                    item.id,
                    tabStripNavId,
                    tabStripNavListId,
                  )

                  // 4. Return the tab strip nav and Content-Group-Wrapper elements fully populated.
                  return [tabStripNav, GroupContent]
                },
              },
            },
          ],
        } // end of this element.

        // 3. Add TabStripNav and Content as Children to Namespaces content.
        //    IF there are children, add them to the root element.
        if (rootElementToRender?.Elements?.[0]) {
          rootElementToRender.Elements[0].children.push(...rootElementToRender.Elements[0].helpers.getChildren())
        }

        // 3. Add the main nav elements to the ElementsProcessed object.
        ElementsProcessed.HtmlElements.push(rootElementToRender)
      } // -- end of if namespace check.
    }) // -- end of looping through root items.
    // 4. Return updated object with the main nav elements within.
    return ElementsProcessed
  }

  /**
   * Utility for building the tab strip nav based on the processed data.
   *
   * Get all modules within the namespace.
   *
   * 1. Build TabStripNav element, a `nav` element, which will hold the tab strip nav list.
   * 2. Execute `TabStripNav.helpers.getChildren()`, which populates all children within TabStripNav.
   * 3. Build the tab strip nav wrapper.
   * 4. Build the tab strip nav list.
   * 5. Build the tab strip nav list items.
   *
   *
   * @returns {Element} TabStripNav - The tab strip nav element.
   * @todo build this out to render content properly.
   * @todo determine if any defaults should exist.
   */
  buildTabStripNav(group: string, parentId: string, tabStripNavId: string, tabStripNavListId: string): Element {
    // 1. Build TabStripNav element, a `nav` element, which will hold the tab strip nav list.
    const TabStripNav: Element = {
      id: tabStripNavId,
      parent: parentId,
      description: "Nav container holding the nav element and it's children within content-wrapper for group.",
      elementType: 'nav',
      classList: ['w-full flex flex-row gap-2 bg-gray-100'],
      dataAttributes: {
        value: null,
        type: null,
        path: null,
        role: 'tab-strip-nav',
        group: group || parentId,
        subGroup: null,
        id: null,
        active: false,
      },
      children: [],
      helpers: {
        getChildren: () => {
          // 3. Build the tab strip nav wrapper. (See step 2 below, which calls this function. )
          const tabStripNavList: Element = {
            id: tabStripNavListId,
            // id: tabStripNavListId,
            parent: tabStripNavId,
            description: `List holding tab-strip-nav-links for namespace with id: '${parentId}'.`,
            elementType: 'ul',
            classList: ['flex w-full flex-row w-full gap-2 w-full'],
            dataAttributes: {
              value: null,
              type: null,
              path: null,
              role: 'tab-strip-nav-list', //-- Role of content when rendered to the UI.
              group: group || parentId,
              subGroup: null,
              id: null,
              active: false,
            },
            children: [],
            helpers: {
              getChildren: () => {
                // 4. Create container to hold tab-strip-nav-link elements. (See step 2 below, which calls this function.)
                const tabStripLinks: Element[] = []
                // 5. Get all modules within the namespace.
                this.processedData.map((item: CommentsProcessed) => {
                  // 6. If item's parent is the namespace, build it.
                  if (
                    item.parent.filter(
                      itemParent => itemParent.id === parentId,
                      // && itemParent.type === 'file',
                    ).length > 0
                  ) {
                    // console.log('navStrip.item to build: ', item.id)
                    const tabStripLink: Element = {
                      id: item.id,
                      parent: tabStripNavListId,
                      // description: `Link within the tab-strip-nav-list for for module '${item.modules[0]}' within namespace '${item.namespaces[0]}'.`,
                      description:
                        item.description ||
                        item.summary ||
                        `Link within the tab-strip-nav-list for for module '${item.modules[0]}' within namespace '${item.namespaces[0]}'.`,
                      elementType: 'li',
                      classList: [
                        'bg-white h-full py-2 px-4 rounded-t-md border-2 border-solid border-b-blue-500 hover:bg-opacity-90 hover:border-b-blue-500/50',
                      ],
                      dataAttributes: {
                        value:
                          item.namespaces[0]?.toUpperCase() ||
                          item.modules[0]?.toUpperCase() ||
                          item.type?.description ||
                          'no-value-set',
                        type: item.type?.type || item.type?.description || null,
                        path: item.fileDetails.filePath,
                        role: 'tab-strip-nav-link', //-- Role of content when rendered to the UI.
                        group:
                          group ||
                          item.namespaces[0] ||
                          item.memberOf?.filter(value => value.type == 'namespace')[0]?.description ||
                          item.parent?.filter(value => value.type == 'namespace')[0]?.description ||
                          item.modules[0] ||
                          item.memberOf?.filter(value => value.type == 'module')[0]?.description ||
                          null,
                        //-- Either Module, Type Description ( like file name, function name, etc), or NULL
                        subGroup: item.modules[0] || item.type?.description || null,
                        id: item.modules[0],
                        active: false,
                      },
                      children: [],
                      helpers: {
                        getChildren: () => [],
                      },
                    }
                    // 6.Populate TabStripLinks array with this link.
                    tabStripLinks.push(tabStripLink)
                  }
                }) // End of building TabStripNavLink
                // 7. return all children links within tab-strip-nav
                return tabStripLinks
              }, // end of tabStripNavList declaration.
            }, // end of tabStripNavList declaration.
          } // end of tabStripNavList declaration.
          // 8. Get children.
          tabStripNavList.children.push(...tabStripNavList.helpers.getChildren())
          // 9. Return children Elements for tabStripNav.
          return [tabStripNavList]
        },
      },
    } // end of tabStripNav declaration.

    // 2.Executes TabStripNav's getChildren helper to populate all children within TabStripNav.
    // ( This executes steps 3 - 9. )
    TabStripNav.children.push(...TabStripNav.helpers.getChildren())

    // 8. return the tab-strip-nav with links.
    return TabStripNav
  }

  /**
   *
   * @param parentId - The ID of the parent element to be used to get data to render content for.
   * @returns
   * @todo build this out to render content properly.
   * @todo determine if any defaults should exist.
   */
  buildGroupContent(group: string, parentId: string, ElementsProcessed: ElementsProcessed): Element[] {
    // 1. Create container to holder all content for namespace / file (should be module).
    const content_modulesInNamespace: Element[] = []

    // 2. Loop through processed data.
    this.processedData.map((item: CommentsProcessed) => {
      // 3. Get the children of the parent element.
      let itemCount = 0 // Used to determine if the item is the first item in the list.
      //  If Module is a member of the namespace.
      if (item.parent.filter(parent => parent.id === parentId).length > 0) {
        // 3. Create the content for the module.
        const content: Element = {
          id: item.id,
          parent: ElementsProcessed.parents.contentWrapper || null,
          description: `Content for ${item.id} module within namespace ${parentId}.`,
          //-- Used for Classifications, special behaviors, etc. (In HTML, used to create attributes, starting with `data-`.)
          elementType: 'div',
          classList: ['content'],
          dataAttributes: {
            value: item, //TODO: Parse so real content, not just raw data.
            type: item.type?.type || item.type?.description || null,
            path: item.fileDetails.filePath,
            role: 'content', //-- Role of content when rendered to the UI.
            active: itemCount === 0 ? true : false,
            //-- Either Namespace or Module
            group:
              group ||
              item.namespaces[0] ||
              item.memberOf?.filter(value => value.type == 'namespace')[0]?.description ||
              item.parent?.filter(value => value.type == 'namespace')[0]?.description ||
              item.modules[0] ||
              item.memberOf?.filter(value => value.type == 'module')[0]?.description ||
              null,
            //-- Either Module, Type Description ( like file name, function name, etc), or NULL
            subGroup: item.modules[0] || item.type?.description || null,
            id: item.modules[0],
          },
          children: [],
          helpers: {
            getChildren: () => [],
          },
        } // End of building element

        itemCount++ // Increment the item count.

        // 4. Push it into the content_modulesInNamespace array.
        content_modulesInNamespace.push(content)
      }
    }) // -- end of looping through processed data.

    // 5. return built elements.
    return content_modulesInNamespace
  }

  //----------------------------------------------------------------------------
  //----------------------------------------------------------------------------
  //-- Actually rendering UI content, here.

  async getHtml():Promise<string>{
    const html = new BuildHtml(this.LogLevel, this.elements, this.title, this.htmlConfig)
    return await html.build();
  }

  /**
   * Convert the data to Markdown
   * @return {string} The Markdown string
   * @todo Implement the method
   */
  toMarkdown(): string {
    // Implement the method as before...
    return ''
  }
}

module.exports = JsonToUi
