/**
 * @access private
 * @file JsonToUi\index.ts
 * @summary Contains class for converting JSON data generated by BuildDocs module into markdown and/or HTML.
 * @namespace {build-docs.JsonToUi}
 * @module JsonToUi
 * @memberof namespace:build-docs
 * @changelog 0.0.1 | 2023-07-13 | Erik Plachta | Initial version
 * @changelog 0.0.2 | 2023-07-14 | Erik Plachta | Built out more complete data extraction
 * @changelog 0.0.3 | 2023-07-15 | Erik Plachta | Finalized data extraction for building HTML. Add files,
 *
 */

import {
  Comments, //-- Comments built by DocsToJson, ready to be processed.
  CommentsProcessed,
  Namespace,
  Module,
  File,
  JsonToUiConfig,
  Element,
  Elements,
  ElementsProcessed,
} from '../types'
import { randomUUID } from 'crypto'

/**
 * @access private
 * @class
 * @memberof module:JsonToUi
 * @summary Converting JSON data generated by BuildDocs module into markdown and/or HTML.
 * @param {DataItem[]} data - The JSON data to convert
 * @param {Config} config - The configuration for the conversion
 * @todo 2023-07-15 | Erik Plachta | Add more complete config options
 * @todo 2023-07-15 | Erik Plachta | Add html generation
 * @todo 2023-07-15 | Erik Plachta | Add markdown generation
 */
/**
 * Class to convert JSON data to Markdown and HTML
 */
class JsonToUi {
  comments: Comments[]
  files: File[]
  namespaces: Namespace[]
  modules: Module[]
  processedData: CommentsProcessed[] | []
  rootItems: CommentsProcessed[] | []
  elements: ElementsProcessed
  config: JsonToUiConfig

  /**
   * @access private
   * @constructor
   * @summary When class instantiated, process data and build elements.
   * @param {Comments[]} comments - The JSON data object containing all comment info to converted.
   * @param {Config} config - The configuration for the conversion.
   */
  constructor(
    comments: Comments[],
    //TODO: onboard this.
    config: {
      convertToMarkdown: boolean
      convertToHtml: boolean
    },
  ) {
    this.comments = comments
    this.config = config
    this.files = []
    this.namespaces = []
    this.modules = []
    this.processedData = this.processComments(comments)

    //-- All top-level items that represent a group of info. (Ex, the file that contains a class, functions, etc)
    this.rootItems = this.getRootItems()
    //-- Evaluate `this.processedData` and `this.rootItems`, assign `ContentToRender` values.
    this.elements = this.buildElements()
  }

  //----------------------------------------------------------------------------
  /**
   * Process data for easier use
   * @param {Comments[]} comments - The data to process
   * @return {CommentsProcessed[]} The processed data
   * @todo 2013-07-18 | Erik Plachta | Move into DocsToJson module from here.
   */
  processComments(comments: Comments[]): CommentsProcessed[] {
    const processedData: CommentsProcessed[] = []

    //-----------------------------
    // 1. First pass through all items to extract individual doc info.
    comments.map((item: Comments) => {
      processedData.push({
        id: item.id,

        //-- if it's got a namespace it's a root item.
        isRootItem: item.comments?.namespace?.[0]?.description ? true : false,

        fileDetails: {
          //-- All return this even if it's not a file because it's relational reference.
          fileName: item.fileName,
          filePath: item.filePath,
          createdDate: item.createdDate,
          modifiedDate: item.modifiedDate,
        },

        type: item.comments?.type?.[0]?.description
          ? {
              type: item.comments?.type?.[0]?.description
                .split('}')[0]
                .replace('{', ''),
              description: item.comments?.type?.[0]?.description
                .split('}')[1]
                .trim(),
            }
          : item.comments?.file?.[0]?.description
          ? {
              type: 'file',
              description: item.comments?.file?.[0]?.description,
            }
          : null,

        version: item.comments?.version?.[0]?.description
          ? item.comments?.version?.[0]?.description
          : null,

        author: item.comments?.author?.[0]?.description
          ? item.comments?.author?.[0]?.description
          : null,

        access: item.comments?.access?.[0]?.description
          ? item.comments?.access?.[0]?.description
          : null,

        description: item.comments?.description?.[0]?.description
          ? item.comments?.description?.[0]?.description
          : null,

        summary: item.comments?.summary?.[0]?.description
          ? item.comments?.summary?.[0]?.description
          : null,

        props:
          item.comments?.param?.length > 0
            ? item.comments.param.map(param => {
                const args = param.description.match(
                  /(\{[^}]*\}|\[[^\]]*\]|`[^`]*`|[^ ]+)/g,
                )
                const [type, name, ...description] = args || []

                return {
                  id: item.id,
                  type: type?.replace('{', '').replace('}', '') || null,
                  name: name?.replace('[', '').replace(']', '') || null,
                  description: description?.join(' ').replace('-', '') || null,
                }
              })
            : [],

        arguments:
          item.comments?.argument?.length > 0
            ? item.comments?.argument.map(argument => {
                const args = argument.description.match(
                  /(\{[^}]*\}|\[[^\]]*\]|`[^`]*`|[^ ]+)/g,
                )
                const [type, name, ...description] = args || []

                return {
                  id: item.id,
                  type: type?.replace('{', '').replace('}', '') || '',
                  name: name?.replace('[', '').replace(']', '') || '',
                  description: description?.join(' ').replace('-', '') || '',
                }
              })
            : [],

        changelog:
          item.comments?.changelog?.length > 0
            ? item.comments?.changelog.map(changelog => {
                return changelog?.description
              })
            : [],

        todo:
          item.comments?.todo?.length > 0
            ? item.comments?.todo.map(todo => {
                return todo?.description
              })
            : [],

        bug:
          item.comments?.bug?.length > 0
            ? item.comments?.bug.map(bug => {
                return bug?.description
              })
            : [],

        example:
          item.comments?.example?.length > 0
            ? item.comments?.example.map(example => {
                return example?.description
              })
            : [],

        //-----------------------------
        //-- Creating empty values for the below, which will be populated on next pass.
        parent: [],
        children: [],
        related: [],

        //-----------------------------
        //-- Extract description from comment for namespace(s)
        namespaces:
          item.comments?.namespace?.length > 0
            ? item.comments?.namespace.map(namespace => {
                //-- Cleanup description to prepare to record
                const description = namespace?.description
                  .replace('{', '')
                  .replace('}', '')

                //-- Record namespace if isn't already defined in global state.
                // ( Should never create duplicates either way, but just in case. )
                if (
                  this.namespaces.filter(
                    item => description !== item.description,
                  ).length === 0
                ) {
                  this.namespaces.push({
                    id: item.id,
                    description: description,
                  })
                }

                //-- return object for the item itself as a value for the `namespaces` property.
                return description
              })
            : [],

        //-----------------------------
        //-- Extract description from comment for module(s)
        modules:
          item.comments?.module?.length > 0
            ? item.comments?.module.map(thisModule => {
                const value = thisModule.description
                this.modules.push({
                  id: item.id,
                  description: value,
                })
                return value
              })
            : [],

        //-----------------------------
        memberOf:
          item.comments?.memberof?.length > 0
            ? item.comments?.memberof.map(memberof => {
                const value = memberof?.description.split(':')
                return {
                  type: value[0],
                  description: value[1],
                }
              })
            : [],

        requires:
          item.comments?.requires?.length > 0
            ? item.comments?.requires.map(require => {
                const rootDesc = require.description
                const { type, name, description } = rootDesc.includes(
                  'https://nodejs.org/api',
                )
                  ? //-- Node Module
                    {
                      type: 'node-module',
                      name: rootDesc.split(' | ')[1]?.replace('}', ''),
                      description: rootDesc
                        .split('{@link ')[1]
                        ?.split(' | ')[0],
                    }
                  : rootDesc.split(':')[0].includes('module')
                  ? //-- Custom Module
                    {
                      // id: item?.id || null,
                      type: rootDesc.split(':')[0],
                      name: rootDesc.split(':')[1],
                      description: rootDesc.split(':')[1],
                    }
                  : //-- Everything else that isn't programmed in yet.
                    {
                      // id: item?.id || null,
                      type: 'unknown', //TODO: update this
                      name: null,
                      description: rootDesc,
                    }
                return {
                  id: item.id,
                  type: type || null,
                  name: name || null,
                  description: description || null,
                }
              })
            : [],
      })
    })

    // 2. Second  pass to add associations between items, recording files, etc
    processedData.map((item: CommentsProcessed) => {
      // 2.1. if has an @memberof tagging.
      if (item?.memberOf && item?.memberOf?.length > 0) {
        item.memberOf.map(memberOf => {
          //-----------------
          // 1.1 Assign relationships for namespaces
          if (memberOf.type === 'namespace') {
            this.namespaces.map(thisNamespace => {
              if (thisNamespace.description === memberOf.description) {
                //-- Add the parent id as the parent to the children
                item.parent.push({
                  id: thisNamespace.id,
                  type: item?.type?.type || null,
                  association: 'namespace',
                  description: thisNamespace.description,
                })
              } else {
                //TODO: onboard or remove this logic.
                // console.log('thisNamespace.value, memberOf.value', thisNamespace.value, memberOf.value)
                const allMemberValues = memberOf?.description.split(' | ') || []
                // const match = allMemberValues.filter((value) => { value === thisNamespace.value })
                const allNamespaceValues =
                  thisNamespace.description.split(' | ') || []
                // const match = allNamespaceValues.filter((value) => { value === memberOf.value })
              }
            })
          }

          //-----------------
          // 1.2. Assign relationships for modules
          if (memberOf.type === 'module') {
            //-- Loop through all modules, check to see if the item is a member of the module.
            this.modules.map(thisModule => {
              if (thisModule.description === memberOf.description) {
                //-- Add the parent id as the parent to the children
                item.parent.push({
                  id: thisModule.id,
                  type: item?.type?.type || null,
                  association: 'module',
                  description: thisModule.description,
                })

                //-- Find the parent and assign the child id to it
                processedData.map((parentItem: CommentsProcessed) => {
                  if (parentItem.id === thisModule.id) {
                    parentItem.children.push({
                      id: item.id,
                      type: item.type?.type || null,
                      association: 'module',
                      description: thisModule.description,
                    })
                  }
                }) // end of adding children associations for parent members of modules
              } // end of module names match
            }) // end of checking match for module names
          } //-- end of checking if memberOf.type === 'module'
        }) //-- end of looping through all memberOf
      } //-- end of checking if item.memberOf.length > 0

      //------------------------------------------------------------------
      // 2.2 If item is a file append this.files array. (children added after this loop)
      if (
        item.type?.type &&
        item.type.type == 'file' &&
        item.type?.description &&
        item.type?.description != (undefined || null)
      ) {
        this.files.push({
          id: item.id,
          description: item.type.description,
          filePath: item.fileDetails.filePath,
        })
      }
    }) //-- end of looping through all processedData

    // 3. If item is NOT a Root Item, add it's parent file to the files parent array.
    processedData.map((item: CommentsProcessed) => {
      if (item?.isRootItem != true) {
        // 3.1 If item is NOT a Root Item, add it's parent file to the files parent array.
        this.files.map(file => {
          if (file.filePath === item.fileDetails.filePath) {
            item.parent.push({
              id: file.id,
              type: item?.type?.type || null,
              association: 'file',
              description: file.description,
            })
          }
          // 3.2 Make sure proper parent association
          else {
            let fileToUpdate: any = processedData.filter(CommentsProcessed => {
              CommentsProcessed.id === file.id
            })
            //-- If there is a file, and there is not already an entry for it, add it.
            if (
              fileToUpdate.children &&
              fileToUpdate.children.filter((child: any) => child.id !== item.id)
            ) {
              fileToUpdate.children.push({
                id: item.id,
                type: 'file',
                description: file.description,
              })
            }
          }
        })
      }
    }) //-- end of looping through all processedData

    return processedData
  }

  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //-- Building Content associations based on processed results:

  /**
   * @access private
   * @type {function} getRootItems
   * @function getRootItems
   * @memberof module:JsonToUi
   * @summary Take `this.rootItems` and build `ContentToRender` object.
   * @returns {boolean} True if successful, false if not.
   */
  getRootItems(): CommentsProcessed[] | [] {
    try {
      //-- Get the root items
      const rootItems = this.processedData?.filter(
        (item: CommentsProcessed) => {
          if (
            // item.parent.length === 0 ||
            item.isRootItem == true
          ) {
            return item
          }
        },
      )

      return rootItems
    } catch (error) {
      console.error(error)
      return []
    }
  }

  getItemsByParent(parent: string): CommentsProcessed[] | undefined | boolean {
    try {
      //-- Get the root items
      const items = this.processedData?.filter((item: CommentsProcessed) => {
        if (item.parent.length > 0) {
          item.parent.map(parent => {
            if (parent.id === item.id) {
              return item
            }
          })
        }
      })

      return items
    } catch (error) {
      console.error(error)
      return false
    }
  }

  //----------------------------------------------------------------------------
  //----------------------------------------------------------------------------
  //-- Building actual objects based on what UI content needs.

  /**
   *
   * @return {array[object]} - An array of objects, each containing the id of the element, the id of the processed item it relates to, and the data to render.
   */
  buildElements(): ElementsProcessed {
    // 1. Create an array to hold the Element and all related info to be generated.
    let ElementsProcessed: ElementsProcessed = {
      id: randomUUID(),
      createdDate: new Date(),
      parents: {
        headerNav: randomUUID(),
        headerNavLinks: randomUUID(),
        main: randomUUID(),
        tabStripNav: randomUUID(),
        contentWrapper: randomUUID(),
        container: randomUUID(),
      },
      Elements: [],
    } // end of base declaration.

    // 2. Build the Main navigation, one link for each namespace.
    ElementsProcessed = this.buildMainNav(ElementsProcessed)

    // 3. Build Content Wrapper, Tab-Strip-Nav, and Content for each namespace.
    ElementsProcessed = this.buildMainContent(ElementsProcessed)

    // 4. Returns finalized ElementsProcessed object.
    return ElementsProcessed
  }

  //-------------------------------
  //-- Utilities used by buildElements

  /**
   * Extracts namespaces from the processed data, creates main nav elements for each.
   * @access private
   * @type {function} buildMainNav
   * @function buildMainNav
   * @param {object} ElementsProcessed - The object containing all elements to be rendered.
   * @return {object} ElementsProcessed - The object containing all elements to be rendered.
   */
  buildMainNav(ElementsProcessed: ElementsProcessed): ElementsProcessed {
    // 1. Create a container to hold all nav links, the Header-nav.
    const HeaderNav: Elements = {
      id: ElementsProcessed.parents.headerNavLinks, //-- The ID of the raw json data all content is being rendered from.
      createdDate: new Date(),
      parents: {
        ...ElementsProcessed.parents,
      },
      Elements: [
        {
          id: ElementsProcessed.parents.headerNavLinks,
          parent: ElementsProcessed.parents.headerNav,
          description: `Main navigation wrapper, holding a link for each namespace.`,
          elementType: 'li',
          dataAttributes: {
            value: null,
            type: null,
            path: null,
            role: 'nav-header', //-- Role of content when rendered to the UI.
            group: null,
            subGroup: null,
            id: null,
          },
          children: [],
          helpers: { getChildren: () => [] },
        },
      ],
    } // end of base UL to hold LIs.

    // 2. Get all Namespaces and create main nav elements for them.
    this.rootItems.map((item: CommentsProcessed) => {
      if (item.namespaces.length > 0) {
        // 2. Create the main nav elements for each namespace.
        const HeaderNavLink: Element = {
          id: item.id,
          parent: ElementsProcessed.parents.headerNavLinks,
          description: `Link within the main navigation for module: ${item.modules[0]}`,
          //-- Used for Classifications, special behaviors, etc. (In HTML, used to create attributes, starting with `data-`.)
          elementType: 'li',
          dataAttributes: {
            value: item.namespaces[0],
            type: item.type?.type || item.type?.description || null,
            path: item.fileDetails.filePath,
            role: 'nav-header-link', //-- Role of content when rendered to the UI.
            group: item.namespaces[0], //-- Used to target content to make visible.
            subGroup: null, //-- none at this level. // TODO: Verify this is correct.
            id: item.namespaces[0], //-- Unique ID to connect tab-strip-nav to it's related content to display. For example, `overview-summary` is the id for the overview tab and the overview content.
          },
          children: [],
          helpers: { getChildren: () => [] },
        } // end of HeaderNavLink declaration.

        // 3. Add the nav link to the HeaderNav object.
        if (HeaderNav.Elements?.[0].children) {
          HeaderNav.Elements[0].children.push(HeaderNavLink)
        }
      }
    }) // -- end of making links for namespaces.

    // 4. Add the main navigation UL and children LIs to the ElementsProcessed object.
    ElementsProcessed.Elements.push(HeaderNav)

    // 5. Return updated object with the main nav elements within.
    return ElementsProcessed
  }

  //-------------------------------------
  //-- Build Content Wrapper, Tab-Strip-Nav, and Content for each namespace.

  /**
   * Evaluates namespaces and creates content to be built into main.
   * @access private
   * @type {function} buildMainContent
   * @function buildMainContent
   * @param {object} ElementsProcessed - The object containing all elements to be rendered.
   * @return {object} ElementsProcessed - The object containing all elements to be rendered.
   * @summary Evaluates namespaces and creates content to be built into main.
   * @description For each namespace, creates a content wrapper, tab-strip-nav, and content.
   * @fires buildTabStripNav
   * @fires buildContentWrapper
   * @fires buildContent
   */
  buildMainContent(ElementsProcessed: ElementsProcessed): ElementsProcessed {
    // 1. Get all Namespaces and create main nav elements for them.
    this.rootItems.map((item: CommentsProcessed) => {
      if (item.namespaces.length > 0) {
        // 2. Create the main nav elements for each namespace.
        const rootElementToRender: Elements = {
          id: item.id, //-- The ID of the raw json data all content is being rendered from.
          createdDate: new Date(),
          parents: {
            ...ElementsProcessed.parents,
            container: item.id,
          },
          Elements: [
            //-------------
            // 3.2.1 - header-nav-link
            {
              id: item.id,
              parent: ElementsProcessed.parents.main,
              description: `Content wrapper for group ${item.namespaces[0]} content within main.}`,
              //-- Used for Classifications, special behaviors, etc. (In HTML, used to create attributes, starting with `data-`.)
              elementType: 'div',
              dataAttributes: {
                value: null,
                type: null,
                path: item.fileDetails.filePath,
                role: 'content-wrapper',
                group: item.namespaces[0],
                subGroup: null,
                id: item.namespaces[0], //-- Unique ID to connect tab-strip-nav to it's related content to display. For example, `overview-summary` is the id for the overview tab and the overview content.
              },
              children: [],
              helpers: {
                // 2. Build the content and it's children
                getChildren: () => {
                  const tabStripNav: Element[] = this.buildTabStripNav(
                    item.id,
                    ElementsProcessed,
                  )
                  const content: Element[] = this.buildContent(
                    item.id,
                    ElementsProcessed,
                  )

                  // return [...tabStripNav, ...content]
                  return [...tabStripNav, ...content]
                },
              },
            },
          ],
        } // end of this element.

        // 3. Add TabStripNav and Content as Children to Namespaces content.
        //    IF there are children, add them to the root element.
        if (rootElementToRender?.Elements?.[0]) {
          rootElementToRender.Elements[0].children.push(
            ...rootElementToRender.Elements[0].helpers.getChildren(),
          )
        }

        // 3. Add the main nav elements to the ElementsProcessed object.
        ElementsProcessed.Elements.push(rootElementToRender)
      } // -- end of if namespace check.
    }) // -- end of looping through root items.
    // 4. Return updated object with the main nav elements within.
    return ElementsProcessed
  }

  /**
   * Utility for building the tab strip nav based on the processed data.
   *
   * Get all modules within the namespace.
   *
   * @returns null
   * @todo build this out to render content properly.
   * @todo determine if any defaults should exist.
   */
  buildTabStripNav(
    parentId: string,
    ElementsProcessed: ElementsProcessed,
  ): Element[] {
    // 1. Get the parent element.
    const tabStripLinks_modulesInNamespace: Element[] = []

    // 2. Build the tab strip nav wrapper.
    const tabStripNav: Element = {
      id: ElementsProcessed.parents.tabStripNav,
      parent: ElementsProcessed.parents.contentWrapper,
      description: `Tab strip nav for namespace: ${parentId}`,
      //-- Used for Classifications, special behaviors, etc. (In HTML, used to create attributes, starting with `data-`.)
      elementType: 'ul',
      dataAttributes: {
        value: null,
        type: null,
        path: null,
        role: 'tab-strip-nav', //-- Role of content when rendered to the UI.
        group: parentId, //-- High-level association of content in nav-header to the main container. Each Root item should only have 1.
        subGroup: parentId, //-- Primary module that's running the show.
        id: parentId, //-- Unique ID to connect tab-strip-nav to it's related content to display. For example, `overview-summary` is the id for the overview tab and the overview content.
      },
      children: [],
      helpers: {
        getChildren: () => {
          // 3. Loop through processed data
          const tabStripLinks: Element[] = []

          this.processedData.map((item: CommentsProcessed) => {
            console.log('item: ', item.type?.type)
            // 3. Get the children of the parent element.
            // If Module is a member of the namespace.
            if (
              item.parent.filter(
                itemParent => itemParent.id === parentId,
                // && itemParent.type === 'file',
              ).length > 0
            ) {
              console.log('navStrip.item to build: ', item.id)
              // 4. Then build an element for it.
              const tabStripLink: Element = {
                id: item.id,
                parent: ElementsProcessed.parents.tabStripNav,
                description: `Link within the main navigation for module: ${item.modules[0]}`,
                //-- Used for Classifications, special behaviors, etc. (In HTML, used to create attributes, starting with `data-`.)
                elementType: 'li',
                dataAttributes: {
                  value: item.modules[0],
                  type: item.type?.type || item.type?.description || null,
                  path: item.fileDetails.filePath,
                  role: 'tab-strip-link', //-- Role of content when rendered to the UI.
                  group: item.namespaces[0], //-- High-level association of content in nav-header to the main container. Each Root item should only have 1.
                  subGroup: item.modules[0], //-- Primary module that's running the show.
                  id: item.modules[0], //-- Unique ID to connect tab-strip-nav to it's related content to display. For example, `overview-summary` is the id for the overview tab and the overview content.
                },
                children: [],
                helpers: {
                  getChildren: () => [],
                },
              }
              // 5. Push the element to the tabStripLinks array.
              tabStripLinks.push(tabStripLink)
            }
          })

          // 6. return all children links within tab-strip-nav
          return tabStripLinks
        },
      },
    }

    // 7. Get children.
    tabStripNav.children.push(...tabStripNav.helpers.getChildren())

    // 8. Push populated tab-strip-nav to be merged into the namespaces content.
    tabStripLinks_modulesInNamespace.push(tabStripNav)

    // 9. return the tab-strip-nav with links.
    return tabStripLinks_modulesInNamespace
  }

  /**
   *
   * @param parentId - The ID of the parent element to be used to get data to render content for.
   * @returns
   * @todo build this out to render content properly.
   * @todo determine if any defaults should exist.
   */
  buildContent(
    parentId: string,
    ElementsProcessed: ElementsProcessed,
  ): Element[] {
    // 1. Create container to holder all content for namespace / file (should be module).
    const content_modulesInNamespace: Element[] = []

    // 2. Loop through processed data.
    this.processedData.map((item: CommentsProcessed) => {
      // 3. Get the children of the parent element.
      //  If Module is a member of the namespace.
      if (item.parent.filter(parent => parent.id === parentId).length > 0) {
        // 3. Create the content for the module.
        const content: Element = {
          id: item.id,
          parent: ElementsProcessed.parents.contentWrapper || null,
          description: `Content for ${item.id} module within namespace ${parentId}.`,
          //-- Used for Classifications, special behaviors, etc. (In HTML, used to create attributes, starting with `data-`.)
          elementType: 'div',
          dataAttributes: {
            value: item, //TODO: Parse so real content, not just raw data.
            type: item.type?.type || item.type?.description || null,
            path: item.fileDetails.filePath,
            role: 'content', //-- Role of content when rendered to the UI.
            //-- Either Namespace or Module
            group:
              item.namespaces[0] ||
              item.memberOf?.filter(value => value.type == 'namespace')[0]
                ?.description ||
              item.parent?.filter(value => value.type == 'namespace')[0]
                ?.description ||
              item.modules[0] ||
              item.memberOf?.filter(value => value.type == 'module')[0]
                ?.description ||
              null,
            //-- Either Module, Type Description ( like file name, function name, etc), or NULL
            subGroup: item.modules[0] || item.type?.description || null,
            id: item.modules[0],
          },
          children: [],
          helpers: {
            getChildren: () => [],
          },
        }
        // 4. Push it into the content_modulesInNamespace array.
        content_modulesInNamespace.push(content)
      }
    }) // -- end of looping through processed data.

    // 5. return built elements.
    return content_modulesInNamespace
  }

  //----------------------------------------------------------------------------
  //----------------------------------------------------------------------------
  //-- Actually rendering UI content, here.

  /**
   * Convert the data to Markdown
   * @return {string} The Markdown string
   * @todo Implement the method
   */
  toMarkdown(): string {
    // Implement the method as before...
    return ''
  }

  /**
   * Convert the data to HTML
   * @return {string} The HTML string
   * @todo Implement the method
   */
  toHtml(
    title = 'Placeholder Title',
    subTitle = 'Placeholder subtitle for html.',
  ): string {
    return `${title} ${subTitle}`
  }
}

module.exports = JsonToUi
