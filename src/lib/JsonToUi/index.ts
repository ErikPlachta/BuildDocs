/**
 * @access private
 * @file JsonToUi\index.ts
 * @summary Contains class for converting JSON data generated by BuildDocs module into markdown and/or HTML.
 * @namespace {build-docs.JsonToUi}
 * @module JsonToUi
 * @memberof namespace:build-docs
 * @changelog 0.0.1 | 2023-07-13 | Erik Plachta | Initial version
 * @changelog 0.0.2 | 2023-07-14 | Erik Plachta | Built out more complete data extraction
 * @changelog 0.0.3 | 2023-07-15 | Erik Plachta | Finalized data extraction for building HTML. Add files,
 *
 */

import {
  Comments, //-- Comments built by DocsToJson, ready to be processed.
  CommentsProcessed,
  Namespace,
  Module,
  File,
  JsonToUiConfig,
  Element,
  Elements,
  ElementsProcessed,
} from '../types'
import { randomUUID } from 'crypto'

/**
 * @access private
 * @class
 * @memberof module:JsonToUi
 * @summary Converting JSON data generated by BuildDocs module into markdown and/or HTML.
 * @param {DataItem[]} data - The JSON data to convert
 * @param {Config} config - The configuration for the conversion
 * @todo 2023-07-15 | Erik Plachta | Add more complete config options
 * @todo 2023-07-15 | Erik Plachta | Add html generation
 * @todo 2023-07-15 | Erik Plachta | Add markdown generation
 */
/**
 * Class to convert JSON data to Markdown and HTML
 */
class JsonToUi {
  comments: Comments[]
  files: File[]
  namespaces: Namespace[]
  modules: Module[]
  processedData: CommentsProcessed[] | []
  rootItems: CommentsProcessed[] | []
  elements: ElementsProcessed
  config: JsonToUiConfig

  /**
   * @access private
   * @constructor
   * @summary When class instantiated, process data and build elements.
   * @param {Comments[]} comments - The JSON data object containing all comment info to converted.
   * @param {Config} config - The configuration for the conversion.
   */
  constructor(
    comments: Comments[],
    //TODO: onboard this.
    config: {
      convertToMarkdown: boolean
      convertToHtml: boolean
    },
  ) {
    this.comments = comments
    this.config = config
    this.files = []
    this.namespaces = []
    this.modules = []
    this.processedData = this.processComments(comments)

    //-- All top-level items that represent a group of info. (Ex, the file that contains a class, functions, etc)
    this.rootItems = this.getRootItems()
    //-- Evaluate `this.processedData` and `this.rootItems`, assign `ContentToRender` values.
    this.elements = this.buildElements()
  }

  //----------------------------------------------------------------------------
  /**
   * Process data for easier use
   * @param {Comments[]} comments - The data to process
   * @return {CommentsProcessed[]} The processed data
   * @todo 2013-07-18 | Erik Plachta | Move into DocsToJson module from here.
   */
  processComments(comments: Comments[]): CommentsProcessed[] {
    const processedData: CommentsProcessed[] = []

    //-----------------------------
    // 1. First pass through all items to extract individual doc info.
    comments.map((item: Comments) => {
      processedData.push({
        id: item.id,

        //-- if it's got a namespace it's a root item.
        isRootItem: item.comments?.namespace?.[0]?.description ? true : false,

        fileDetails: {
          //-- All return this even if it's not a file because it's relational reference.
          fileName: item.fileName,
          filePath: item.filePath,
          createdDate: item.createdDate,
          modifiedDate: item.modifiedDate,
        },

        type: item.comments?.type?.[0]?.description
          ? {
              type: item.comments?.type?.[0]?.description
                .split('}')[0]
                .replace('{', ''),
              description: item.comments?.type?.[0]?.description
                .split('}')[1]
                .trim(),
            }
          : item.comments?.file?.[0]?.description
          ? {
              type: 'file',
              description: item.comments?.file?.[0]?.description,
            }
          : null,

        version: item.comments?.version?.[0]?.description
          ? item.comments?.version?.[0]?.description
          : null,

        author: item.comments?.author?.[0]?.description
          ? item.comments?.author?.[0]?.description
          : null,

        access: item.comments?.access?.[0]?.description
          ? item.comments?.access?.[0]?.description
          : null,

        description: item.comments?.description?.[0]?.description
          ? item.comments?.description?.[0]?.description
          : null,

        summary: item.comments?.summary?.[0]?.description
          ? item.comments?.summary?.[0]?.description
          : null,

        props:
          item.comments?.param?.length > 0
            ? item.comments.param.map(param => {
                const args = param.description.match(
                  /(\{[^}]*\}|\[[^\]]*\]|`[^`]*`|[^ ]+)/g,
                )
                const [type, name, ...description] = args || []

                return {
                  id: item.id,
                  type: type?.replace('{', '').replace('}', '') || null,
                  name: name?.replace('[', '').replace(']', '') || null,
                  description: description?.join(' ').replace('-', '') || null,
                }
              })
            : [],

        arguments:
          item.comments?.argument?.length > 0
            ? item.comments?.argument.map(argument => {
                const args = argument.description.match(
                  /(\{[^}]*\}|\[[^\]]*\]|`[^`]*`|[^ ]+)/g,
                )
                const [type, name, ...description] = args || []

                return {
                  id: item.id,
                  type: type?.replace('{', '').replace('}', '') || '',
                  name: name?.replace('[', '').replace(']', '') || '',
                  description: description?.join(' ').replace('-', '') || '',
                }
              })
            : [],

        changelog:
          item.comments?.changelog?.length > 0
            ? item.comments?.changelog.map(changelog => {
                return changelog?.description
              })
            : [],

        todo:
          item.comments?.todo?.length > 0
            ? item.comments?.todo.map(todo => {
                return todo?.description
              })
            : [],

        bug:
          item.comments?.bug?.length > 0
            ? item.comments?.bug.map(bug => {
                return bug?.description
              })
            : [],

        example:
          item.comments?.example?.length > 0
            ? item.comments?.example.map(example => {
                return example?.description
              })
            : [],

        //-----------------------------
        //-- Creating empty values for the below, which will be populated on next pass.
        parent: [],
        children: [],
        related: [],

        //-----------------------------
        //-- Extract description from comment for namespace(s)
        namespaces:
          item.comments?.namespace?.length > 0
            ? item.comments?.namespace.map(namespace => {
                //-- Cleanup description to prepare to record
                const description = namespace?.description
                  .replace('{', '')
                  .replace('}', '')

                //-- Record namespace if isn't already defined in global state.
                // ( Should never create duplicates either way, but just in case. )
                if (
                  this.namespaces.filter(
                    item => description !== item.description,
                  ).length === 0
                ) {
                  this.namespaces.push({
                    id: item.id,
                    description: description,
                  })
                }

                //-- return object for the item itself as a value for the `namespaces` property.
                return description
              })
            : [],

        //-----------------------------
        //-- Extract description from comment for module(s)
        modules:
          item.comments?.module?.length > 0
            ? item.comments?.module.map(thisModule => {
                const value = thisModule.description
                this.modules.push({
                  id: item.id,
                  description: value,
                })
                return value
              })
            : [],

        //-----------------------------
        memberOf:
          item.comments?.memberof?.length > 0
            ? item.comments?.memberof.map(memberof => {
                const value = memberof?.description.split(':')
                return {
                  type: value[0],
                  description: value[1],
                }
              })
            : [],

        requires:
          item.comments?.requires?.length > 0
            ? item.comments?.requires.map(require => {
                const rootDesc = require.description
                const { type, name, description } = rootDesc.includes(
                  'https://nodejs.org/api',
                )
                  ? //-- Node Module
                    {
                      type: 'node-module',
                      name: rootDesc.split(' | ')[1]?.replace('}', ''),
                      description: rootDesc
                        .split('{@link ')[1]
                        ?.split(' | ')[0],
                    }
                  : rootDesc.split(':')[0].includes('module')
                  ? //-- Custom Module
                    {
                      // id: item?.id || null,
                      type: rootDesc.split(':')[0],
                      name: rootDesc.split(':')[1],
                      description: rootDesc.split(':')[1],
                    }
                  : //-- Everything else that isn't programmed in yet.
                    {
                      // id: item?.id || null,
                      type: 'unknown', //TODO: update this
                      name: null,
                      description: rootDesc,
                    }
                return {
                  id: item.id,
                  type: type || null,
                  name: name || null,
                  description: description || null,
                }
              })
            : [],
      })
    })

    // 2. Second  pass to add associations between items, recording files, etc
    processedData.map((item: CommentsProcessed) => {
      // 2.1. if has an @memberof tagging.
      if (item?.memberOf && item?.memberOf?.length > 0) {
        item.memberOf.map(memberOf => {
          //-----------------
          // 1.1 Assign relationships for namespaces
          if (memberOf.type === 'namespace') {
            this.namespaces.map(thisNamespace => {
              if (thisNamespace.description === memberOf.description) {
                //-- Add the parent id as the parent to the children
                item.parent.push({
                  id: thisNamespace.id,
                  type: item?.type?.type || null,
                  association: 'namespace',
                  description: thisNamespace.description,
                })
              } else {
                //TODO: onboard or remove this logic.
                // console.log('thisNamespace.value, memberOf.value', thisNamespace.value, memberOf.value)
                const allMemberValues = memberOf?.description.split(' | ') || []
                // const match = allMemberValues.filter((value) => { value === thisNamespace.value })
                const allNamespaceValues =
                  thisNamespace.description.split(' | ') || []
                // const match = allNamespaceValues.filter((value) => { value === memberOf.value })
              }
            })
          }

          //-----------------
          // 1.2. Assign relationships for modules
          if (memberOf.type === 'module') {
            //-- Loop through all modules, check to see if the item is a member of the module.
            this.modules.map(thisModule => {
              if (thisModule.description === memberOf.description) {
                //-- Add the parent id as the parent to the children
                item.parent.push({
                  id: thisModule.id,
                  type: item?.type?.type || null,
                  association: 'module',
                  description: thisModule.description,
                })

                //-- Find the parent and assign the child id to it
                processedData.map((parentItem: CommentsProcessed) => {
                  if (parentItem.id === thisModule.id) {
                    parentItem.children.push({
                      id: item.id,
                      type: item.type?.type || null,
                      association: 'module',
                      description: thisModule.description,
                    })
                  }
                }) // end of adding children associations for parent members of modules
              } // end of module names match
            }) // end of checking match for module names
          } //-- end of checking if memberOf.type === 'module'
        }) //-- end of looping through all memberOf
      } //-- end of checking if item.memberOf.length > 0

      //------------------------------------------------------------------
      // 2.2 If item is a file append this.files array. (children added after this loop)
      if (
        item.type?.type &&
        item.type.type == 'file' &&
        item.type?.description &&
        item.type?.description != (undefined || null)
      ) {
        this.files.push({
          id: item.id,
          description: item.type.description,
          filePath: item.fileDetails.filePath,
        })
      }
    }) //-- end of looping through all processedData

    // 3. If item is NOT a Root Item, add it's parent file to the files parent array.
    processedData.map((item: CommentsProcessed) => {
      if (item?.isRootItem != true) {
        // 3.1 If item is NOT a Root Item, add it's parent file to the files parent array.
        this.files.map(file => {
          if (file.filePath === item.fileDetails.filePath) {
            item.parent.push({
              id: file.id,
              type: item?.type?.type || null,
              association: 'file',
              description: file.description,
            })
          }
          // 3.2 Make sure proper parent association
          else {
            let fileToUpdate: any = processedData.filter(CommentsProcessed => {
              CommentsProcessed.id === file.id
            })
            //-- If there is a file, and there is not already an entry for it, add it.
            if (
              fileToUpdate.children &&
              fileToUpdate.children.filter((child: any) => child.id !== item.id)
            ) {
              fileToUpdate.children.push({
                id: item.id,
                type: 'file',
                description: file.description,
              })
            }
          }
        })
      }
    }) //-- end of looping through all processedData

    return processedData
  }

  //--------------------------------------------------------------------------
  //--------------------------------------------------------------------------
  //-- Building Content associations based on processed results:

  /**
   * @access private
   * @type {function} getRootItems
   * @function getRootItems
   * @memberof module:JsonToUi
   * @summary Take `this.rootItems` and build `ContentToRender` object.
   * @returns {boolean} True if successful, false if not.
   */
  getRootItems(): CommentsProcessed[] | [] {
    try {
      //-- Get the root items
      const rootItems = this.processedData?.filter(
        (item: CommentsProcessed) => {
          if (
            // item.parent.length === 0 ||
            item.isRootItem == true
          ) {
            return item
          }
        },
      )

      return rootItems
    } catch (error) {
      console.error(error)
      return []
    }
  }

  getItemsByParent(parent: string): CommentsProcessed[] | undefined | boolean {
    try {
      //-- Get the root items
      const items = this.processedData?.filter((item: CommentsProcessed) => {
        if (item.parent.length > 0) {
          item.parent.map(parent => {
            if (parent.id === item.id) {
              return item
            }
          })
        }
      })

      return items
    } catch (error) {
      console.error(error)
      return false
    }
  }

  //----------------------------------------------------------------------------
  //----------------------------------------------------------------------------
  //-- Building actual objects based on what UI content needs.

  /**
   *
   * @return {array[object]} - An array of objects, each containing the id of the element, the id of the processed item it relates to, and the data to render.
   */
  buildElements(): ElementsProcessed {
    // 1. Create an array to hold the Element and all related info to be generated.
    let ElementsProcessed: ElementsProcessed = {
      id: randomUUID(),
      createdDate: new Date(),
      parents: {
        headerNav: randomUUID(),
        headerNavLinks: randomUUID(),
        main: randomUUID(),
      },
      Elements: [],
    } // end of base declaration.

    //TODO: 2023-07-17 | Erik Plachta | Onboard this below once decide to use like this or remove.
    // const headerNavId = randomUUID()
    // let headerNavLinksId = randomUUID()
    // const mainId = randomUUID()

    // // 3. Loop through all Root Items and generate base content.
    // this.rootItems.map((item: CommentsProcessed) => {
    //   return false; //! TODO: Re-enable this once buildMainNav is onboarded.

    //   let containerId = randomUUID()
    //   let tabStripNavId = randomUUID()
    //   let contentWrapperId = randomUUID()

    //   const rootElementToRender: Elements = {
    //     id: item.id, //-- The ID of the raw json data all content is being rendered from.
    //     createdDate: new Date(),
    //     parents: {
    //       ...ElementsProcessed.parents,
    //       container: containerId,
    //       tabStripNav: tabStripNavId,
    //       contentWrapper: contentWrapperId,
    //     },
    //     //-----------------
    //     // 3.1 - Get all root data for reference.
    //     //TODO: 2023-07-18 | Erik Plachta | Decide if this is needed and purge if not.
    //     // data: {
    //     //   // item: item,
    //     //   //-- data to reference when building content.
    //     //   changelog: [], // item.changelog || [],
    //     //   props: [], // item.props || [],
    //     //   arguments: [], // item.arguments || [],
    //     //   returns: [], // item.returns || [],
    //     //   requires: [], // item.requires || [],
    //     //   parent: item.parent, // item.parent || null,
    //     //   children: [], // item.children || []
    //     // },
    //     //-----------------
    //     //-- 3.2 Array of all content to be rendered
    //     Elements: [
    //       //-------------
    //       // 3.2.1 - header-nav-link
    //       {
    //         id: item.id,
    //         parent: 'nav-header',
    //         description: `Link within the main navigation for module: ${item.modules[0]}`,
    //         //-- Used for Classifications, special behaviors, etc. (In HTML, used to create attributes, starting with `data-`.)
    //         elementType: 'li',
    //         dataAttributes: {
    //           value: item.modules[0],
    //           type: item.type?.type || item.type?.description || null,
    //           path: item.fileDetails.filePath,
    //           role: 'nav-header-link', //-- Role of content when rendered to the UI.
    //           group: item.namespaces[0], //-- High-level association of content in nav-header to the main container. Each Root item should only have 1.
    //           subGroup: item.namespaces[0], //-- Primary module that's running the show.
    //           id: item.modules[0], //-- Unique ID to connect tab-strip-nav to it's related content to display. For example, `overview-summary` is the id for the overview tab and the overview content.
    //         },
    //         children: [],
    //         helpers: {
    //           getChildren: () => {
    //             const tabStripLinks: Element[] = []
    //             const relatedRequires: Element[] = []
    //             const relatedContent: Element[] = []

    //             //!! TODO: Pick up here, by getting all child elements and managing accordingly. Then to go through each.
    //             this.rootItems.forEach(rootItem => {
    //               console.log('rootItem.requires: ', rootItem?.modules?.[0])

    //               //-- Elements to be rendered in the tab-strip-nav for the root item.
    //               const tabStripNavElement: Element = {
    //                 id: randomUUID(),
    //                 description: `A nav-link within tab-strip-nav for root module ${item.modules[0]}, this module: ${rootItem.modules[0]}}`,
    //                 parent: tabStripNavId,
    //                 children: [],
    //                 elementType: 'li',
    //                 dataAttributes: {
    //                   value: rootItem.modules[0],
    //                   type: rootItem?.type?.type || null,
    //                   path: rootItem.fileDetails.filePath,
    //                   role: 'tab-strip-nav-link',
    //                   group: rootItem.namespaces[0],
    //                   subGroup: rootItem.modules[0],
    //                   id: `${rootItem.modules[0]}-tab-strip-nav-link`,
    //                 },
    //                 helpers: {
    //                   getChildren: () => [],
    //                 },
    //               }
    //               //-- populate children
    //               tabStripNavElement.children =
    //                 tabStripNavElement.helpers.getChildren()
    //               //-- Update array
    //               tabStripLinks.push(tabStripNavElement)

    //               /**
    //                * @summary Loop a second time to get all related content for the root items.
    //                * @describe IF the root item has an @require tag, check for matched ID match to current root item. IF match, then create a new element for the tab-strip-nav for the root item.
    //                *
    //                * @todo 2023-07-18 | Erik Plachta | See if this is needed or if the main item loop is sufficient.
    //                */
    //               rootItem.requires &&
    //                 rootItem?.id?.length > 0 &&
    //                 //-- Loop through all @require items
    //                 rootItem.requires.forEach(entry => {
    //                   //-- loop through all Comments Processed to find a requirement match within the root item.
    //                   this.processedData.map((child: CommentsProcessed) => {
    //                     //-- If a requirement Match is found, create a new element for the tab-strip-nav for the root item.
    //                     if (entry.id == child.id) {
    //                       //-- Build element.
    //                       const childElement = {
    //                         id: randomUUID(),
    //                         parent: rootItem.id,
    //                         elementType: 'div',
    //                         description: `Requirement for '${rootItem.modules[0]}', for module: ${child.modules[0]}`,
    //                         dataAttributes: {
    //                           // type: rootItem?.type?.type, //
    //                           value: rootItem.modules[0],
    //                           role: 'requirement',
    //                           group: rootItem.namespaces[0],
    //                           subGroup: rootItem.modules[0],
    //                           id: `${child.modules[0]}-required`,
    //                         },
    //                         children: [],
    //                         helpers: {
    //                           getChildren: () => [],
    //                         },
    //                       } //-- end of building the child elements
    //                       //-- Update the parent element with the child element.
    //                       childElement.children.push(
    //                         ...childElement.helpers.getChildren(),
    //                       )
    //                       //-- Update the relatedRequires array with the child element.
    //                       //! TODO: Onboard this push ot remove full requires
    //                       // relatedRequires.push(childElement)
    //                     } // -- end of root items requires loop.
    //                   })
    //                 })
    //             }) //-- End of each group rendering.

    //             return [...tabStripLinks, ...relatedRequires]
    //           },
    //         },
    //       },
    //     ], //--  END of creating elements for each Root Item.
    //   }

    //   rootElementToRender.Elements != undefined &&
    //     rootElementToRender.Elements.forEach((element: Element) => {
    //       element.children = element.helpers.getChildren()
    //     })

    //   // 4.0 - Add the root item to the elements.data array.
    //   ElementsProcessed.Elements.push(rootElementToRender)
    // })

    ElementsProcessed = this.buildMainNav(ElementsProcessed)
    ElementsProcessed = this.buildMainContent(ElementsProcessed)

    //---------------------------------
    // 5. Map through ALL Content to Render and make sure children are populated.
    //! TODO: Onboard getChildren calling here, to reduce # of calls. (right now happens in loop above and duplicates for all root items.)

    // // Recursively populate children of each ContentToRender element.
    // function populateChildren(element: Element) {
    //   // Call getChildren method to populate children.
    //   if (element.hasOwnProperty('getChildren')) {
    //     element.children = element.helpers.getChildren()
    //   }

    //   // Recursively call populateChildren for each child.
    //   if (element.children) {
    //     element.children.forEach((child: Element) => populateChildren(child))
    //   }
    // }
    // for (let i = 0; i < ElementsProcessed.data.length; i++) {
    //   // console.log('i: ', i, ' - ', ElementsProcessed.data[i].Elements)
    //   // for(let j = 0; j < ElementsProcessed.data; j++) {
    //   //   populateChildren(ElementsProcessed.data[i][j])
    //   // }
    // }

    // 4. Finally, return the elements array.
    return ElementsProcessed
  }

  /**
   * Extracts namespaces from the processed data, creates main nav elements for each.
   */
  buildMainNav(ElementsProcessed: ElementsProcessed): ElementsProcessed {
    // 1. Get all Namespaces and create main nav elements for them.
    this.rootItems.map((item: CommentsProcessed) => {
      if (item.namespaces.length > 0) {
        // 2. Create the main nav elements for each namespace.
        const rootElementToRender: Elements = {
          id: item.id, //-- The ID of the raw json data all content is being rendered from.
          createdDate: new Date(),
          parents: {
            ...ElementsProcessed.parents,
          },
          Elements: [
            //-------------
            // 3.2.1 - header-nav-link
            {
              id: item.id,
              parent: ElementsProcessed.parents.headerNavLinks,
              description: `Link within the main navigation for module: ${item.modules[0]}`,
              //-- Used for Classifications, special behaviors, etc. (In HTML, used to create attributes, starting with `data-`.)
              elementType: 'li',
              dataAttributes: {
                value: item.modules[0],
                type: item.type?.type || item.type?.description || null,
                path: item.fileDetails.filePath,
                role: 'nav-header-link', //-- Role of content when rendered to the UI.
                group: item.namespaces[0], //-- High-level association of content in nav-header to the main container. Each Root item should only have 1.
                subGroup: item.namespaces[0], //-- Primary module that's running the show.
                id: item.modules[0], //-- Unique ID to connect tab-strip-nav to it's related content to display. For example, `overview-summary` is the id for the overview tab and the overview content.
              },
              children: [],
              helpers: {
                getChildren: () => [],
              },
            },
          ],
        } // end of this element.

        // 3. Add the main nav elements to the ElementsProcessed object.
        ElementsProcessed.Elements.push(rootElementToRender)
      } // -- end of if namespace check.
    }) // -- end of looping through root items.
    // 4. Return updated object with the main nav elements within.
    return ElementsProcessed
  }

  /**
   * Utility for building the tab strip nav based on the processed data.
   *
   * @returns null
   * @todo build this out, changing it's arg.
   */
  buildTabStripNav(parentId : string):Element[]{

    // 1. Get the parent element.

    // 2. Get the children of the parent element. ( all modules that are members of namespace )

    // 3. return built elements.
    
    return []
  }

buildContent(parentId : string):Element[]{

  // 1. Get the parent element.

  // 2. Get the children of the parent element. ( all modules that are members of namespace )

  // 3. return built elements.

  return []
}

  /**
   * Evaluates namespaces and creates content to be built into main.
   */
  buildMainContent(ElementsProcessed: ElementsProcessed): ElementsProcessed {
    // 1. Get all Namespaces and create main nav elements for them.
    this.rootItems.map((item: CommentsProcessed) => {
      if (item.namespaces.length > 0) {
        // 2. Create the main nav elements for each namespace.
        const rootElementToRender: Elements = {
          id: item.id, //-- The ID of the raw json data all content is being rendered from.
          createdDate: new Date(),
          parents: {
            ...ElementsProcessed.parents,
            container: item.id,
          },
          Elements: [
            //-------------
            // 3.2.1 - header-nav-link
            {
              id: item.id,
              parent: ElementsProcessed.parents.main,
              description: `Content wrapper for group ${item.namespaces[0]} content within main.}`,
              //-- Used for Classifications, special behaviors, etc. (In HTML, used to create attributes, starting with `data-`.)
              elementType: 'div',
              dataAttributes: {
                value: null,
                type: null,
                path: item.fileDetails.filePath,
                role: 'nav-header-link', //-- Role of content when rendered to the UI.
                group: item.namespaces[0], //-- High-level association of content in nav-header to the main container. Each Root item should only have 1.
                subGroup: item.namespaces[0], //-- Primary module that's running the show.
                id: item.modules[0], //-- Unique ID to connect tab-strip-nav to it's related content to display. For example, `overview-summary` is the id for the overview tab and the overview content.
              },
              children: [],
              helpers: {
                // 2. Build the content and it's children
                getChildren: () => { 
                  const tabStripNav :Element[] = this.buildTabStripNav(item.id)
                  const content :Element[] = this.buildContent(item.id)

                  return [
                    ...tabStripNav,
                    ...content
                    ]
                },
              },
            },
          ],
        } // end of this element.

        // 3. Add the main nav elements to the ElementsProcessed object.
        ElementsProcessed.Elements.push(rootElementToRender)
      } // -- end of if namespace check.
    }) // -- end of looping through root items.
    // 4. Return updated object with the main nav elements within.
    return ElementsProcessed
  }

  //--------------------------------------------------------------------------
  /**
   * Convert the data to Markdown
   * @return {string} The Markdown string
   * @todo Implement the method
   */
  toMarkdown(): string {
    // Implement the method as before...
    return ''
  }

  /**
   * Convert the data to HTML
   * @return {string} The HTML string
   * @todo Implement the method
   */
  toHtml(
    title = 'Placeholder Title',
    subTitle = 'Placeholder subtitle for html.',
  ): string {
    return `${title} ${subTitle}`
  }
}

module.exports = JsonToUi
